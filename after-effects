#!/usr/bin/env bash
# shellcheck disable=SC2059,SC2154,SC2034,SC2155
# vim: filetype=sh

# Author: Prasad Tengse
# Licence: GPLv3
# Github Repository: https://github.com/tprasadtp/ubuntu-post-install
# Requirements - Bash v4 and above
#              - whiptail, wget, awk, sed, grep
#

set -o pipefail

readonly AE_EXEC_START=$(date +%s)
readonly SCRIPT=$(basename "$0")

# SCRIPT METADATA
readonly dir=$(cd -P -- "$(dirname -- "$0")" && pwd -P)

# Version
readonly AE_VERSION="8.0.2"

# Handle Use interrupt
# trap ctrl-c and call ctrl_c()
trap ctrl_c_handler INT

function ctrl_c_handler() {
  printf "${RED}• User Interrupt! CTRL-C${NC}\n"
  exit 4
}

function _init_printf_variables() {
  #Initialize printf variables
  readonly _phase_repo="(REPO)"
  readonly _phase_ppa="(PPA)"
  readonly _phase_install="(INST)"
  readonly _phase_purge="(PURGE)"
  readonly _phase_deb="(DPKG)"
  readonly _phase_apt="(APT)"
  readonly _phase_apt_key="(KEYS)"
  readonly _phase_snap="(SNAP)"

  # Log Premitives
  readonly _info="[INF]"
  readonly _dev="[DEV]"
  readonly _debug="[DBG]"
  readonly _cleanup="[DEL]"
  readonly _success="[ OK]"
  readonly _warn="[WRN]"
  readonly _error="[ERR]"
  readonly _variable="[VAR]"
  readonly _crit="[CRT]"

  #colors for display
  readonly YELLOW=$'\e[38;5;220m'
  readonly GREEN=$'\e[32m'
  readonly RED=$'\e[31m'
  readonly BLUE=$'\e[34m'
  readonly LIGHT_BLUE=$'\e[38;5;159m'
  readonly CYAN=$'\e[38;5;51m'
  readonly NC=$'\e[0m'
  readonly ORANGE=$'\e[38;5;208m'
  readonly TEAL=$'\e[38;5;192m'
  readonly PINK=$'\e[38;5;212m'
  readonly GRAY=$'\e[38;5;246m'
  readonly LOG_GRAY=$'\e[38;5;240m'
  readonly LIGHT_GRAY=$'\e[38;5;242m'
  readonly MAGENTA=$'\e[38;5;219m'
}

function _init_logging() {
  # Initialize phase 2
  # Only variables necessary for logging & start logging
  # Script related variables are defined in _init_script_variables
  readonly log_file="$dir"/logs/after-effects.log
  local bool_created_logfile

  {
    mkdir -p "$dir"/logs
  } ||
    {
      printf "${RED}✕ Failed to create logs folder${NC}\n"
      exit 2
    }
  # tmp dir
  {
    rm -rf /tmp/ae/*
    mkdir -p /tmp/ae/
  } ||
    {
      printf "${RED}✕ Failed to create tmp folder${NC}\n"
      exit 2
    }

  # if file not exists touch it
  if [[ ! -f ${log_file} ]]; then
    if touch "${log_file}"; then
      bool_created_logfile="true"
    else
      printf "${RED}✕ Failed to create logfile!${NC}\n"
      exit 2
    fi
  fi

  # check if logs can be written
  if [[ -w $log_file ]]; then
    {
      log_debug "$(_line_fill)"
      [[ $bool_created_logfile == "true" ]] && log_debug "Created log file: ${log_file}"
      log_debug "Initialized logging"
    } ||
      {
        printf "${RED}✕ Failed to write to log file ${log_file} ${NC}\n"
        exit 2
      }
  else
    printf "${RED}✕ Log file is not writable!${NC}\n"
    exit 2
  fi
}

# Utility Functions
function _line_fill() {
  printf "_______________________________________________________\n"
}

function log_and_exit() {
  # ARG-1 log msg
  # ARG-2 exit code int
  local msg="$1"
  printf "${RED}✖ $msg ${NC}\n"
  printf "$(date) ${_crit} $msg\n" >>"$log_file"
  exit "$2"
}

function _script_exit_log() {
  # Script time
  log_stage "Cleanup and Exit"
  readonly AE_EXEC_END=$(date +%s)
  readonly AE_EXEC_TIME=$((AE_EXEC_END - AE_EXEC_START))
  log_debug "$SCRIPT took $AE_EXEC_TIME seconds to complete."
  exit 0
}

function log_info() {
  local msg="$1"
  printf "  • $msg\n"
  printf "$(date) ${_info} $msg\n" >>"$log_file"
}

function log_debug() {
  local msg="$1"
  if [[ ${AE_DEBUG} -gt 0 ]]; then
    printf "${GRAY}  • $msg ${NC}\n"
  fi
  printf "$(date) ${_debug} $msg\n" >>"$log_file"
}

function log_success() {
  local msg="$1"
  printf "${TEAL}  • $msg ${NC}\n"
  printf "$(date) ${_success} $msg\n" >>"$log_file"
}

function log_warn() {
  local msg="$1"
  printf "${YELLOW}  • $msg ${NC}\n"
  printf "$(date) ${_warn} $msg\n" >>"$log_file"
}

function log_stage() {
  local msg="$1"
  printf "${MAGENTA}➜ $msg ${NC}\n"
  printf "$(date) ${_info} $msg\n" >>"$log_file"
}

function log_error() {
  local msg="$1"
  printf "${RED}  • $msg ${NC}\n"
  printf "$(date) ${_error} $msg\n" >>"$log_file"
}

function log_dev() {
  local msg="$1"
  printf "${ORANGE}  • $msg ${NC}\n"
  printf "$(date) ${_dev} $msg\n" >>"$log_file"
}

function log_notice() {
  local msg="$1"
  printf "${CYAN}  • $msg${NC}\n"
  printf "$(date) ${_info} $msg\n" >>"$log_file"
}

function log_var() {
  local var
  var="$1"
  if [[ $AE_DEBUG -gt 0 ]]; then
    printf "${GRAY}  » %-22s - %-10s${NC}\n" "${var}" "${!var}"
  fi
  printf "$(date) ${_variable} %-22s - %-10s\n" "${var}" "${!var}" >>"$log_file"
}

function log_trace() {
  # This function adds time stamp to logs without using external utilities
  # Output will be automatically written to $log_file
  # Arguments : 1
  # ARG -1: printf variable for formatting the log
  # Usage command | _add_timestamp_to_logs "$1"
  while IFS= read -r line; do
    printf "$(date) [EXT] ${1} %s\n" "$line" &>>"$log_file"
    if [[ $AE_DEBUG -gt 1 ]]; then
      printf "${LOG_GRAY}  » %s %s${NC}\n" "$1" "$line"
    fi
  done

}

function log_property() {
  # Args (4)
  # Arg 1 : Property name
  # Arg 2 : Property value
  # Arg 3 : log level can be 0-debug(default)
  #                          1-info
  #                          2-notice
  #                          3-dev
  #                          4-warning
  #                          5-error
  #                          other defaults to debug.
  # Arg 4 : Format string  spacing (default=18)
  local desc value fmt lvl
  local __msg_string
  desc="${1}"
  value="${2}"
  lvl="${3:-0}"
  fmt="%-${4:-22}s"
  __msg_string="$(printf "${fmt} : %s" "${desc}" "${value}")"

  case ${lvl} in
  0) log_debug "${__msg_string}" ;;
  1) log_info "${__msg_string}" ;;
  2) log_notice "${__msg_string}" ;;
  3) log_dev "${__msg_string}" ;;
  4) log_warn "${__msg_string}" ;;
  5) log_error "${__msg_string}" ;;
  *) log_debug "${__msg_string}" ;;
  esac
}

#shellcheck disable=SC2120
function detect_distribution() {
  # Read /etc/os-release and get
  local OS_RELEASE_FILE

  OS_RELEASE_FILE="${1:-/etc/os-release}"
  if [[ -r "${OS_RELEASE_FILE}" ]]; then
    log_debug "Found os-release file ${OS_RELEASE_FILE}"
    # Read Version Code Name
    readonly AE_DISTRO_CODENAME="$(awk '/VERSION_CODENAME=/' "${OS_RELEASE_FILE}" | sed 's/VERSION_CODENAME=//' | tr '[:upper:]' '[:lower:]')"

    # Read Human Readable Full Version Name
    readonly AE_DISTRO_PRETTY_NAME="$(awk '/PRETTY_NAME=/' "${OS_RELEASE_FILE}" | sed 's/PRETTY_NAME=//' | tr -d '"')"

    # Read Human Readable Distro Name
    readonly AE_DISTRO_NAME="$(awk '/^NAME=/' "${OS_RELEASE_FILE}" | sed 's/^NAME=//' | tr -d '"')"
  else
    log_error "Hey, What kind of system is this?"
    log_and_exit "I cannot determine distro/codename!" "5"
  fi
}

function _init_script_variables() {
  # Function defines Script variables
  # Necessary variables used by the script are initialized here. This function
  # should be called first before choices are made, always.

  #shellcheck disable=SC2119
  detect_distribution

  # Achtung: Do not set code_name as readonly!!
  code_name="${AE_DISTRO_CODENAME}"
  readonly architecture="$(dpkg --print-architecture)"
  case "${architecture}" in
  amd64)
    log_debug "Architecture is 64 bit."
    readonly ARCH="amd64"
    ;;
  armhf)
    log_debug "Running on ARM CPU with HW Floating point Processor"
    readonly ARCH="armhf"
    ;;
  arm64)
    log_debug "This is an ARM64. Please be advised that not all repositories support this arch."
    readonly ARCH="arm64"
    ;;
  *)
    log_error "Sorry! This architecture is not supported by this script!"
    log_and_exit "Unsupported Architecture. $(architecture)" "11"
    ;;
  esac

  # Get Hostname
  readonly CLIENT_NAME=$(hostname)

  # etc sources list dir
  readonly SOURCES_FILE_DIR=/etc/apt/sources.list.d

  # Trusted keys
  if [[ -v ${TRUSTED_KEYRINGS_DIR} ]]; then
    log_and_exit "Reserved variable (TRUSTED_KEYRINGS_DIR) is set!" "66"
  else
    readonly TRUSTED_KEYRINGS_DIR=/usr/share/keyrings
  fi

  # AE_OBS_PREFIX check
  if [[ -v ${AE_OBS_PREFIX} ]]; then
    log_and_exit "Reserved variable (AE_OBS_PREFIX) is set!" "66"
  fi

  if [[ -v ${AE_BASE_CODENAME} ]]; then
    log_and_exit "Reserved variable (AE_BASE_CODENAME) is set!" "66"
  fi

  # Ping URL
  readonly PING_URL="http://connectivitycheck.gstatic.com/generate_204"

  #-------------------------- Release codenames --------------------------------------
  readonly codename_latest_release="hirsute"
  readonly codename_previous_release="groovy"

  # 404 is a placeholder which is  set when there are
  # no suitable releases which can use this feature or
  # the release is unknown or too early in developement.
  readonly codename_upcoming_release="impish"

  readonly codename_current_lts="focal"
  readonly codename_previous_lts="bionic"

  readonly codename_latest_debian_release="buster"
  readonly codename_upcoming_debian_release="bullseye"

  #============================ Switches/ booleans & Vars ================================

  # Fix Repo not available for latest release
  bool_fix_repo_not_available_for_latest="false"

  # Allow repo fixes for Upcoming releases of ubuntu and its derivatives.
  bool_fix_repo_not_available_for_upcoming_release="false"

  # By default version checks are enabled
  bool_check_version="true"

  # Not used
  readonly api_version_url="https://ae.prasadt.com/get/v3/version"

  # Azure
  readonly AZURE_METADATA_URL="http://169.254.169.254/metadata/instance/compute/location?api-version=2017-08-01&format=text"

  # Achtung!!
  # ========================================================================================= #

  # Purge not required packages
  # Default is false
  # Requires command line option -d to be passed via command line otherwise it will not work.
  # Set this to true if you don't want to pass -d every time
  bool_purge_pkgs="false"

  # Keep Downloaded DEB packages
  bool_preserve_debs="false"

  #
  # ================================================================================== #
  # Achtung!
  # Do not change any of the variables below this if you don't know what they do.
  # They are essential for correct working of the script.

  # Check Debian Flags
  bool_is_debian="false"

  # Boolean to hold if --fix or --fix-mode-lts or --pre-release was applied
  bool_codename_fix_appied="false"

}

function _init_print_basic_info() {
  # This function logs and displays the Necessary details which helps in debugging.
  # Should be used after _init_script_variables function.
  log_property "Hostname" "${CLIENT_NAME}" 1
  log_property "OS" "${AE_DISTRO_PRETTY_NAME}" 1
  log_property "Distribution" "${AE_DISTRO_NAME}" 1
  log_property "Release" "${AE_DISTRO_CODENAME}" 1
  log_property "Architecture" "${ARCH}" 1
  log_property "Version" "${AE_VERSION}" 1

  log_property "SOURCES_FILE_DIR" "${SOURCES_FILE_DIR}"
  log_property "TRUSTED_KEYRINGS_DIR" "${TRUSTED_KEYRINGS_DIR}"

  #disable hist chars  so that I can print "!!"" properly
  histchars=
}

function delete_log_file() {
  printf "➜ Deleting log file\n"
  if rm "${dir}/logs/after-effects.log"; then
    printf "${GREEN}• Done${NC}\n"
    exit 0
  else
    printf "${RED}• Failed!${NC}\n"
    exit 1
  fi
}

function _check_dependencies() {
  #Checks if commands in array are available.
  # Accepts one argument as array.
  local dependencies=("$@")
  local dependency_check_failed_count dependency
  dependency_check_failed_count=0
  for dependency in "${dependencies[@]}"; do
    if command -v "$dependency" >/dev/null; then
      log_property "${dependency}" "INSTALLED"
    else
      log_property "$dependency" "NOT INSTALLED"
      dependency_check_failed_count=$((dependency_check_failed_count + 1))
    fi
  done

  if [ "$dependency_check_failed_count" -gt 0 ]; then
    log_error "One or more dependencies not installed."
    log_and_exit "Sorry! $SCRIPT cannot continue!" "1"
  fi
}

function _eol_message() {
  # Display EOL Message and upgrade instruction URLs.
  # Arguments: 1
  # ARG 1: EOL Date

  log_error "This version of ${AE_DISTRO_NAME} is no longer supported."
  log_and_exit "${AE_DISTRO_PRETTY_NAME} will reach EOL pretty soon ($1)." "12"
}

function _fix_ubuntu_derivatives() {
  # Some Ubuntu based distributions use their own codename (Linux mint, Elementary)
  # Some repositories require that ubuntu codename is used.
  # This function fixes that for
  # Linux Mint 20.x : Ubuntu 20.04 Xenial,
  # Linux Mint 19.x : Ubuntu 18.04 Xenial,
  # Elementary OS Juno,Hera: Ubuntu 18.04 Xenial
  # Pop!_OS uses Ubuntu codenames (No need to apply fix)
  # KDE Neon, Bodhi, Peppermint use Ubuntu codenames
  # If the release is not known this function exits the script for safety.

  log_stage "Checking for Ubuntu derivates/Debian"
  log_var "code_name"
  case ${code_name} in
  # Ubuntu 18.04 and its derivatives
  bionic)
    readonly enable_ppa="true"
    readonly distro_name="ubuntu"
    log_info "This is a LTS release of Ubuntu (18.04)"
    log_success "Keeping the codename as $code_name."
    ;;
  tara | tessa | tina | tricia)
    log_info "This is Linux-Mint 19.X."
    log_info "Setting additional repositories to follow Ubuntu 18.04."
    code_name="bionic"
    readonly distro_name="ubuntu"
    readonly enable_ppa="true"
    log_success "Changed codename to $code_name"
    ;;
  juno | hera)
    log_info "This release of Elementary OS is based on Ubuntu 18.04 Bionic."
    log_info "External repositories will use Ubuntu 18.04."
    code_name="bionic"
    readonly distro_name="ubuntu"
    readonly enable_ppa="true"
    log_success "Changed codename to $code_name"
    ;;
  # Ubuntu 20.04 and its derivatives (Current Ubuntu LTS release)
  focal)
    readonly enable_ppa="true"
    readonly distro_name="ubuntu"
    log_info "This is latest LTS release of Ubuntu"
    log_success "Keeping the codename as $code_name."
    ;;
  ulyana | ulyssa | uma)
    log_info "Release is Linux mint 20.X."
    log_info "Setting additional repositories to follow Ubuntu 20.04."
    code_name="focal"
    readonly distro_name="ubuntu"
    readonly AE_SNAP_REMOVE_APT_BLOCK="true"
    readonly enable_ppa="true"
    log_success "Changed codename to $code_name"
    ;;
  # Current Ubuntu release
  hirsute)
    readonly enable_ppa="true"
    readonly distro_name="ubuntu"
    log_notice "Release is Ubuntu 21.04 Hirsute Hippo"
    ;;
  # Upcoming Ubuntu release
  impish)
    readonly enable_ppa="true"
    readonly distro_name="ubuntu"
    log_warn "Release is Ubuntu 21.10 (Unstable!!)"
    ;;
  # Old Debian release
  stretch)
    bool_is_debian="true"
    readonly distro_name="debian"
    readonly enable_ppa="false"
    log_notice "This is Debian. PPAs are disabled."
    ;;
  # Current Debian release
  buster)
    bool_is_debian="true"
    readonly distro_name="debian"
    readonly enable_ppa="false"
    log_notice "This is current stable release of Debian. PPAs are disabled."
    ;;
  # Upcoming Debian release
  bullseye)
    bool_is_debian="true"
    readonly enable_ppa="false"
    readonly distro_name="debian"
    log_dev "You are running Debian Testing!"
    log_warn "This is pre release version of Debian. Use with caution!"
    log_notice "PPAs are disabled."
    ;;
  # Unsupported releases
  groovy) _eol_message "June 2021" ;;
  xenial) _eol_message "April 2021" ;;
  sarah | serena | sonya | sylvia) _eol_message "April 2021" ;;
  loki) _eol_message "April 2021" ;;
  *)
    log_and_exit "Unknown or unsupported release($code_name) !!" "16"
    ;;
  esac

  log_success "Applied release specific settings and fixes."
  log_var "code_name"

  # Save a copy of code_name
  declare -gr AE_BASE_CODENAME="${code_name}"
  log_var "AE_BASE_CODENAME"

}

function _test_internet_connection() {
  # Function to check internet connection
  log_info "Checking connectivity"
  if wget --tries=2 --timeout=10 "$PING_URL" -O /dev/null -o /dev/null; then
    log_success "Connected!"
  else
    log_error "You are not connected to the Internet!. "
    log_error "Please check your Internet connection and try again."
    log_and_exit "No internet connection!" "14"
  fi
}

function _test_conflicting_apps() {
  # Function checks if any apps like syanptic aptitude are running.
  local lock
  for lock in synaptic update-manager software-center apt-get dpkg aptitude; do
    # shellcheck disable=SC2009
    if ps -U root -u root u | grep $lock | grep -v grep >/dev/null; then
      log_and_exit "Installation won't work. Please close $lock first then try again." "15"
    else
      log_property "$lock" "not running"
    fi
  done
  log_success "No conflicts detected"
}

function parse_yaml() {
  local yaml_file="${1}"
  local prefix="${2}"
  local s
  local w
  local fs

  s='[[:space:]]*'
  w='[a-zA-Z0-9_.-]*'
  fs="$(echo @ | tr @ '\034')"

  (
    #shellcheck disable=SC1003
    sed -e '/- [^\"]'"[^\']"'.*: /s|\([ ]*\)- \([[:space:]]*\)|\1-\'$'\n''  \1\2|g' |
      sed -ne '/^--/s|--||g; s|\"|\\\"|g; s/[[:space:]]*$//g;' \
        -e "/#.*[\"\']/!s| #.*||g; /^#/s|#.*||g;" \
        -e "s|^\($s\)\($w\)$s:$s\"\(.*\)\"$s\$|\1$fs\2$fs\3|p" \
        -e "s|^\($s\)\($w\)${s}[:-]$s\(.*\)$s\$|\1$fs\2$fs\3|p" |
      awk -F"$fs" '{
          indent = length($1)/2;
          if (length($2) == 0) { conj[indent]="+";} else {conj[indent]="";}
          vname[indent] = $2;
          for (i in vname) {if (i > indent) {delete vname[i]}}
              if (length($3) > 0) {
                  vn=""; for (i=0; i<indent; i++) {vn=(vn)(vname[i])("__")}
                  printf("%s%s%s%s=(\"%s\")\n", "'"$prefix"'",vn, $2, conj[indent-1],$3);
              }
          }' |
      sed -e 's/_=/+=/g' |
      awk 'BEGIN {
                FS="=";
                OFS="="
            }
            /(-|\.).*=/ {
                gsub("-|\\.", "_", $1)
            }
            { print }'
  ) <"$yaml_file"
}

function _get_remote_file() {
  # Function to get remote file/response
  # exits script if it fails.
  # Accepts 2 arguments.
  # ARG 1: File name; Name of the local file the response or file should be saved as.
  # ARG 2: URL to the  file

  local file_name="${1}"
  local exit_status
  local file_url="${2}"
  log_property "URL is set to" "${file_url}"

  if [ "$#" -eq 2 ]; then
    # Remote files
    wget -q "${file_url}" -O "$file_name" >>$"$log_file"
    exit_status="$?"

    log_property "Exit code (wget)" "$exit_status"
    if [[ $exit_status -ne 0 ]]; then
      log_error "Something went wrong while retrieving ${file_name}."
      log_and_exit "Error Getting file." "28"
    fi
  else
    log_and_exit "Invalid number of arguments <_get_remote_file> Requires 2, got $#." "19"
  fi

}

function compare_versions() {
  # Function to compare two semver version strings.
  #
  # REQUIRED ARGUMENTS:
  # Accepts two arguments both of which are semver version strings.
  #
  # ARG1 - CURRENT_SEMVER. Usually obtained from
  #     a) Within the script
  #     b) Executing {binary} --version --short
  #     c) Version marker files from ~/bin or /usr/share/vmark-files/{binary}
  #     d) Package manager's metadata
  # ARG2 - UPSTREAM_SEMVER. Usually obtained from
  #     a) Upcheck API endpoint
  #     b) GitHub releases API
  # This function will NOT handle fetching/reading these values.
  #
  # DEPENDENCIES: One of the following is required.
  #     a) 'sh-logger' snippet from tprasadtp/templates repository.
  #     b) 'log_debug' function. Minimum dummy implementation is below.
  #        ```bash
  #        function log_debug(){}
  #        ```
  # LOGGING: All logs generated by this function are at debug level (handled by `log_debug`).

  # Compares CURRENT_SEMVER and UPSTREAM_SEMVER mostly according to semver specs and sets a
  # global variable VCOMPARE_RESULT to save the result.
  # RESULTS:
  # If CURRENT_SEMVER > UPSTREAM_SEMVER  VCOMPARE_RESULT is -1. (no update required)
  # If CURRENT_SEMVER < UPSTREAM_SEMVER  VCOMPARE_RESULT is  1. (update is required)
  # If CURRENT_SEMVER == UPSTREAM_SEMVER VCOMPARE_RESULT is  0. (no update required)
  # ERRORS:
  #   a) ERROR_INVALID_SEMVER_1    - CURRENT_SEMVER  is invalid
  #   b) ERROR_INVALID_SEMVER_2    - UPSTREAM_SEMVER is invalid
  #   c) ERROR_DEPENDENCY          - 'log_debug' function is not defined
  #   d) ERROR_INCOMPLETE_EVAL     - For some reason, evaluation isn't completed
  #   e) ERROR_UNHANDLED_CONDITION - Unhadled condition.
  #
  # NOTES:
  # Please note that ERROR_INVALID_SEMVER indicates version is not compliant accoring
  # to our versioning policy. It might be a valid semver according to semver specs,
  # but is non compliant with our tagging policy, which follows
  # MAJOR.MINOR.PATCH-<PRERELEASE_IDENTIFIER>.<PRERELEASE_VERSION>
  # For pre releases, PRERELEASE_IDENTIFIER can be 'alpha', 'beta' or 'rc' with an
  # optional <PRERELEASE_VERSION> which MUST be a non negative integer.

  # Default error in case of incomplete evaluation for any other reason
  declare -g VCOMPARE_RESULT="ERROR_INCOMPLETE_EVAL"

  # Check if log_debug function is defined
  if ! declare -F "log_debug" >/dev/null; then
    VCOMPARE_RESULT="ERROR_DEPENDENCY"
    return
  fi

  # Define semver regex according to policy tprasadtp/templates/semver-regex.md
  declare -r SEMVER_REGEX="^[vV]?(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)\.(0|[1-9][0-9]*)(\-(alpha|beta|rc)(\.(0|[1-9][0-9]*))?)?\$"

  local current_semver upstream_semver
  current_semver="$1"
  upstream_semver="$2"

  log_debug "Current  version : ${current_semver}"
  log_debug "Upstream version : ${upstream_semver}"

  local current_major current_minor current_patch current_pre current_pre_num
  local upstream_major upstream_minor upstream_patch upstream_pre upstream_pre_num

  # Parse current semver
  if [[ $current_semver =~ $SEMVER_REGEX ]]; then
    current_major="${BASH_REMATCH[1]}"
    current_minor="${BASH_REMATCH[2]}"
    current_patch="${BASH_REMATCH[3]}"
    current_pre="${BASH_REMATCH[5]}"
    current_pre_num="${BASH_REMATCH[7]}"
    log_debug "Parsed version (current)  -> major:${current_major} minor:${current_minor} patch:${current_patch} pre:${current_pre} prenum:${current_pre_num}"
  else
    VCOMPARE_RESULT="ERROR_INVALID_SEMVER_1"
    return
  fi

  # Parse upstream semver.
  if [[ ${upstream_semver} =~ $SEMVER_REGEX ]]; then
    upstream_major="${BASH_REMATCH[1]}"
    upstream_minor="${BASH_REMATCH[2]}"
    upstream_patch="${BASH_REMATCH[3]}"
    upstream_pre="${BASH_REMATCH[5]}"
    upstream_pre_num="${BASH_REMATCH[7]}"
    log_debug "Parsed version (upstream) -> major:${upstream_major} minor:${upstream_minor} patch:${upstream_patch} pre:${upstream_pre} prenum:${upstream_pre_num}"
  else
    VCOMPARE_RESULT="ERROR_INVALID_SEMVER_2"
    return
  fi

  # Compare semver versions
  # Major version
  if [[ ${upstream_major} -gt ${current_major} ]]; then
    log_debug "Upstream release is newer than current ${upstream_major} > ${current_major} (major)"
    VCOMPARE_RESULT="1"
    return
  elif [[ ${upstream_major} -lt ${current_major} ]]; then
    log_debug "Current version is newer than upstream available ${upstream_major} < ${current_major} (major)"
    VCOMPARE_RESULT="-1"
    return
  fi

  # Minor version
  # This will only be executed if MAJOR versions match.
  if [[ ${upstream_minor} -gt ${current_minor} ]]; then
    log_debug "Upstream release is newer than current ${upstream_minor} > ${current_minor} (minor)"
    VCOMPARE_RESULT="1"
    return
  elif [[ ${upstream_minor} -lt ${current_minor} ]]; then
    log_debug "Current version is newer than upstream available ${upstream_minor} < ${current_minor} (minor)"
    VCOMPARE_RESULT="-1"
    return
  fi

  # Patch version
  # This will only be executed if MAJOR AND MINOR versions match.
  if [[ ${upstream_patch} -gt ${current_patch} ]]; then
    log_debug "Upstream release is newer than current ${upstream_patch} > ${current_patch} (patch)"
    VCOMPARE_RESULT="1"
    return
  elif [[ ${upstream_patch} -lt ${current_patch} ]]; then
    log_debug "Current version is newer than upstream available ${upstream_patch} < ${current_patch} (patch)"
    VCOMPARE_RESULT="-1"
    return
  fi

  # What follows below is the mess of somewhat following semver specs.
  log_debug "Major, Minor and Patch version match."

  # Check if pre release strings are present in one of the versions. whichever lacks pre release string
  # is the upstream one. For Eg. 2.3.6-beta.1 < 2.3.6

  # upstream version has NO pre release fields but current one DOES
  # current: 2.2.2-rc.1 upstream: 2.2.2, then upstream is newer.
  if [[ -z ${upstream_pre} ]] && [[ -n $current_pre ]]; then
    log_debug "Upstream version has no pre release fields, it is newer!"
    VCOMPARE_RESULT="1"
    return
  # upstream version HAS prerelease fields but current one DOES NOT
  # current: 2.2.2 upstream: 2.2.2-rc.1, then current is newer.
  elif [[ -n ${upstream_pre} ]] && [[ -z $current_pre ]]; then
    log_debug "Current version has no pre release fields, it is newer!"
    VCOMPARE_RESULT="-1"
    return
  fi

  # We do not follow complete semver specs.
  # This is done for simplicity. All our versioning policies only include
  # pre release tags of format MAJOR.MINOR.PATCH-<PRERELEASE_IDENTIFIER>.<PRERELEASE_VERSION>
  # In our policies its strictly forbidden to include build numbers and build identifiers in
  # the tags created. We only embed build number information in
  # execultables themeselves or as packaging metadata like docker labels.
  # In case of pre release versions, we only have <PRERELEASE_IDENTIFIER>.<PRERELEASE_VERSION>
  # or <PRERELEASE_IDENTIFIER>. Thus, all other cases are ignored.

  # Check if pre release identifiers match.
  # Spec 11.4.2
  # Identifiers with letters or hyphens are compared lexically in ASCII sort order.
  if [[ $upstream_pre > $current_pre ]]; then
    log_debug "Upstream pre release identider is lexographically greater than current one.(prerelease)"
    VCOMPARE_RESULT="1"
    return
  elif [[ $upstream_pre < $current_pre ]]; then
    log_debug "Current pre release identider is lexographically greater than upstream one.(prerelease)"
    VCOMPARE_RESULT="-1"
    return
  else
    log_debug "Current and upstream pre release identifiers match"
  fi

  # Spec 11.4.4: A larger set of pre-release fields has a higher precedence than a smaller set,
  #              if all of the preceding identifiers are equal.
  # check if both PRERELEASE_VERSION fields are empty, if so both versions are equal.
  if [[ -z $upstream_pre_num ]] && [[ -z $current_pre_num ]]; then
    log_debug "pre-release version identifiers are empty for both fields. (all)"
    VCOMPARE_RESULT="0"
    return
  fi

  # upstream version has pre release version field but current one doesnt
  # current: 2.2.2-rc upstream: 2.2.2.rc.1, then upstream is newer.
  if [[ -z ${upstream_pre_num} ]] && [[ -n $current_pre_num ]]; then
    log_debug "Upstream has pre release number but current one does not. Upstream is newer (prerelease-num)"
    VCOMPARE_RESULT="1"
    return
  # upstream version has lacks pre release version field but current one does
  # current: 2.2.2-rc.1 upstream: 2.2.2.rc, then current is newer.
  elif [[ -n ${upstream_pre_num} ]] && [[ -z $upstream_pre_num ]]; then
    log_debug "Current version pre release number but current one does not. Current version is newer. (prerelease-num)"
    VCOMPARE_RESULT="-1"
    return
  fi

  if [[ ${upstream_pre_num} -gt ${current_pre_num} ]]; then
    log_debug "Upstream release is newer than current ${upstream_pre_num} > ${current_pre_num} (prerelease-num)"
    VCOMPARE_RESULT="1"
    return
  elif [[ ${upstream_pre_num} -lt ${current_pre_num} ]]; then
    log_debug "Current version is newer than upstream available ${upstream_pre_num} < ${current_pre_num} (prerelease-num)"
    VCOMPARE_RESULT="-1"
    return
  elif [[ ${upstream_pre_num} -eq ${current_pre_num} ]]; then
    log_debug "Current and upstream pre release nums match. ${upstream_pre_num} = ${current_pre_num} (all)"
    VCOMPARE_RESULT="0"
    return
  fi

  # We should never reach this condition. If we do, indicate we did not handle all conditions.
  # This should trigger a bug report prompt/message in logs.
  VCOMPARE_RESULT="ERROR_UNHANDLED_CONDITION"
}

function _version_checks() {
  # Checks if its running latest version.
  # Also suggest updating to latest version if current version is not latest,
  # Allows to deprecate old version as it can be suggested.
  # Check if Version Checks is enabled. (Default is enabled)
  declare -g VCOMPARE_RESULT
  local upcheck_gh_api_res

  # Check if update checks are enabled (default=true)
  if [ "$bool_check_version" == "true" ]; then
    log_stage "Checking for updates"

    # Get latest version from GitHub release endpoint
    latest_semver_tag="$(wget -q --timeout 20 --tries 3 -O- https://api.github.com/repos/tprasadtp/ubuntu-post-install/releases/latest | grep -Po '"tag_name": "\K.*?(?=")')"
    upcheck_gh_api_res="$?"
    if [[ $upcheck_gh_api_res -ne 0 ]]; then
      log_error "Failed to check for updates!"
      log_and_exit "Either check your connectivity or disable version checks with --no-version-check" "31"
    fi

    # Remove leading v if necessary
    latest_semver="${latest_semver_tag#v}"
    log_info "Latest available version is ${latest_semver}"

    # Compare versions <CURRR> <UPSTREAM>
    log_debug "Comparing versions"
    compare_versions "${AE_VERSION}" "${latest_semver}"

    # Evaluate
    case $VCOMPARE_RESULT in
    1)
      log_error "Thou art running older version of this script,"
      log_error "Please download latest version and try again."
      log_and_exit "You can disable version checks by passing --no-version-check" "24"
      ;;
    0)
      log_success "Running the latest version!"
      ;;
    -1)
      log_dev "You are running development version of the script"
      ;;
    ERROR_INVALID_SEMVER_1)
      log_warn "Script's semver is invalid! Please report this bug!"
      log_warn "Disabling update checks!"
      ;;
    ERROR_INVALID_SEMVER_2)
      log_warn "Latest version is invalid! Please report this bug!"
      log_warn "Disabling update checks!"
      ;;
    *)
      log_error "Failed to evaluate version check result- ${VCOMPARE_RESULT}"
      log_warn "Disabling update checks!"
      ;;
    esac

  # If version checks have been disabled
  else
    log_warn "Version checks have been disabled."
  fi

}

function _check_bool() {
  # Function to check if config has valid values for bool.
  # Accepted values are true and false
  # If invalid, defaults to false.
  # Accepts global var and bool to check as arguments
  local g_var param_bool default_val
  if [[ $# -eq 2 ]]; then
    default_val="false"
  else
    log_and_exit "Internal error! bool validator takes only two arguments!" "19"
  fi

  g_var="${1}"
  param_bool="${2}"
  case "${param_bool}" in
  true | True | TRUE | Yes | yes | YES | 1) # shellcheck disable=SC2086
    declare -g ${g_var}="true"
    log_var "$g_var"
    ;;
  false | False | FALSE | No | no | NO | 0) # shellcheck disable=SC2086
    declare -g ${g_var}="false"
    log_var "$g_var"
    ;;
  *) # shellcheck disable=SC2086
    declare -g ${g_var}="${default_val}"
    log_var "$g_var"
    ;;
  esac
}

function _set_yaml_config() {
  local config_yaml_file
  # Get and parse the file
  log_stage "Processing configuration"
  if [ "$bool_local_config" != "true" ]; then
    log_property "Config URL" "${url_remote_yaml}" 3
    if [[ -e "/tmp/ae/api-config.yml" ]]; then
      rm -f "/tmp/ae/api-config.yml" || log_and_exit "Deleting old version YAML failed." "38"
    fi
    readonly config_yaml_file="/tmp/ae/api-config.yml"
    # Get response/file
    _get_remote_file "$config_yaml_file" "$url_remote_yaml"
  else
    log_property "Config file" "$local_config_file" 2
    readonly config_yaml_file="$local_config_file"
  fi

  # Parse YAML to variables
  log_property "Parsing config" "$config_yaml_file" 2
  eval "$(parse_yaml "$config_yaml_file")"

  # Repo flags
  #################################################################################
  _check_bool "add_docker_repo" "${config__add_repo__docker[0]}"

  _check_bool "add_winehq_repo" "${config__add_repo__winehq[0]}"

  _check_bool "add_mendeley_repo" "${config__add_repo__mendeley[0]}"

  _check_bool "add_spotify_repo" "${config__add_repo__spotify[0]}"

  _check_bool "add_signal_repo" "${config__add_repo__signal[0]}"

  _check_bool "add_sublimetext_repo" "${config__add_repo__sublimetext[0]}"

  _check_bool "add_podman_repo" "${config__add_repo__podman[0]}"

  # ROS
  _check_bool "add_ros_repo" "${config__add_repo__ros[0]}"
  _check_bool "add_ros2_repo" "${config__add_repo__ros2[0]}"

  # GitHub
  _check_bool "add_gh_repo" "${config__add_repo__github[0]}"

  _check_bool "add_hashicorp_repo" "${config__add_repo__hashicorp[0]}"

  # Google
  _check_bool "add_gvisor_repo" "${config__add_repo__gvisor[0]}"
  _check_bool "add_bazel_repo" "${config__add_repo__bazel[0]}"
  _check_bool "add_gcp_repo" "${config__add_repo__googlecloud[0]}"
  _check_bool "add_gcsfuse_repo" "${config__add_repo__gcsfuse[0]}"
  _check_bool "add_chrome_repo" "${config__add_repo__chrome[0]}"

  # Microsoft
  _check_bool "add_azurecli_repo" "${config__add_repo__azurecli[0]}"
  _check_bool "add_edge_repo" "${config__add_repo__edge[0]}"
  _check_bool "add_skype_repo" "${config__add_repo__skype[0]}"
  _check_bool "add_vscode_repo" "${config__add_repo__vscode[0]}"
  _check_bool "add_msteams_repo" "${config__add_repo__teams[0]}"

  # Debian Components
  _check_bool "add_debian_nonfree" "${config__add_repo__debian_nonfree[0]}"
  _check_bool "add_debian_contrib" "${config__add_repo__debian_contrib[0]}"

  # Ubuntu Components
  _check_bool "add_ubuntu_universe" "${config__add_repo__ubuntu_universe[0]}"
  _check_bool "add_ubuntu_multiverse" "${config__add_repo__ubuntu_multiverse[0]}"
  _check_bool "add_ubuntu_restricted" "${config__add_repo__ubuntu_restricted[0]}"

  # Other Script Flags
  #################################################################################

  # Purge Packages
  if [[ $bool_purge_pkgs == "true" ]]; then
    log_debug "Ignoring config.flags.purge_enabled because of cli flag"
  else
    _check_bool "bool_purge_pkgs" "${config__flags__purge_enabled[0]}"
  fi

  # Keep Debs
  if [[ $bool_preserve_debs == "true" ]]; then
    log_debug "Ignoring config.flags.preserve_debs because of cli flag"
  else
    _check_bool "bool_preserve_debs" "${config__flags__preserve_debs[0]}"
  fi

  # Uni-Mirror
  _check_bool "bool_use_uf_mirror" "${config__flags__uni_freiburg_mirror[0]}"

  # Tasks Flags
  ##################################################################################

  _check_bool "ae_task_update" "${config__tasks__update[0]}"

  _check_bool "ae_task_upgrade" "${config__tasks__upgrade[0]}"

  _check_bool "ae_task_repo" "${config__tasks__repo[0]}"

  _check_bool "ae_task_ppa" "${config__tasks__ppa[0]}"

  _check_bool "ae_task_apt" "${config__tasks__apt[0]}"

  _check_bool "ae_task_debs" "${config__tasks__debs[0]}"

  _check_bool "ae_task_purge" "${config__tasks__purge[0]}"

  _check_bool "ae_task_bin" "${config__tasks__binaries[0]}"

  _check_bool "ae_task_snaps" "${config__tasks__snaps[0]}"

  #################################################################################
  #                              Parse Arrays
  #################################################################################
  # Config file YAML has arrays of apt packages.
  # We need to parse apt packages, ppa's, deb packages, listed in yaml
  # to bash arrays.

  #--------------------------------------------------------------------------------
  #                               APT Lists
  #--------------------------------------------------------------------------------
  # There are Seven lists under key config.install.apt.[mentioned from 1-7]
  # 1. administration : Contains Administrative packages
  # 2. security       : contains Security related tools and packages
  # 3. productivity   : Office tools, writing tools, LateX, document tools and other
  #                     productivity tools, Email clients, browsers, IM clients etc.
  #                   : Example : LateX, TeXStudio, Libre office, pandoc empathy, Thunderbird
  # 4. Multimedia     : Multimedia tools like media players, audio converters and playes etc.
  # 5. development    : IDEs [Spyder, Jetbeans etc], languages [go, python, ruby, rust, java etc],
  #                   : Containers [docker lxc rkt etc], Python libraries, compilers [gcc, clang]
  #                   : SDKs [AWS SDK, Coogle Cloud SDK, open-jdk, Tensor Flow], headers
  #                   : and libraries[ocl-icd-dev],
  #                   : Anything related to development and *-dev or *-devl packages.
  # 6. other          : Everything which doesnot fit in the above categories.
  #                   : Themes, Tools, Utilities like htop etc.
  # 7. External       : Any packages which are provided by ppas, or repositories not present in
  #                   : base *buntu distribution. There's a possibility that the repository might not
  #                   : be added or may be unavailable or offline. So Keeping the list seperate from
  #                   : others packages minimizes errors if there are any.
  # This classification is only for ease of use and need not be strictly followed. You can put
  # vlc package in 'security', it will still install fine. This classification helps
  # while writing configs and editing them. Its advised to follow it if your configs
  # tend to get to couple of hundreds of lines. Also YAML file should be a valid YAML.

  #--------------------------------------------------------------------------------
  #                             Special list - Purge list
  #--------------------------------------------------------------------------------
  # There is a special package list under key, config.purge, which contains
  # list of apt packages to be purged from the system if present.
  # Lets get em, shall we?

  # Copy package array

  # Purge
  declare -gar parsed_purge_packages=("${config__purge_[@]}")

  # Normal
  declare -gar parsed_administration_packages=("${config__install__apt__administration_[@]}")
  declare -gar parsed_secutity_packages=("${config__install__apt__security_[@]}")
  declare -gar parsed_productivity_packages=("${config__install__apt__productivity_[@]}")
  declare -gar parsed_multimedia_packages=("${config__install__apt__multimedia_[@]}")
  declare -gar parsed_development_packages=("${config__install__apt__development_[@]}")
  declare -gar parsed_other_packages=("${config__install__apt__other_[@]}")
  declare -gar parsed_external_packages=("${config__install__apt__external_[@]}")

  #--------------------------------------------------------------------------------
  #                             PPA Lists
  #--------------------------------------------------------------------------------
  # Config file contains list of PPAs to be added under key
  # config.ppa
  declare -gar parsed_ppa_list=("${config__ppa_[@]}")

  #--------------------------------------------------------------------------------
  #                             Debian packages
  #--------------------------------------------------------------------------------
  # Config file contains list of DEB packages to be downloaded & installed under key
  # config.install.debian_packages
  # The configuration is not simple URL its csv. <URL to Deb file>,<Name of the Package>
  # This is for compatiblity reasons
  declare -gar parsed_deb_files_list=("${config__install__debian_packages_[@]}")

  #--------------------------------------------------------------------------------
  #                             Static binaries
  #--------------------------------------------------------------------------------
  declare -gar parsed_bin_packages=("${config__install__binaries_[@]}")

  #--------------------------------------------------------------------------------
  #                             Snap Packages
  #--------------------------------------------------------------------------------
  declare -gar parsed_snap_normal_packages=("${config__install__snaps__normal_[@]}")
  declare -gar parsed_snap_classic_packages=("${config__install__snaps__classic_[@]}")
  declare -gar parsed_snap_edge_packages=("${config__install__snaps__edge_[@]}")

}

function _clean_apt_cache() {
  # Function to clean apt package cache. Takes care of -k flag in all the installs.
  # Honor -k flag
  # Delete DEBs
  if [ "$bool_preserve_debs" != "true" ]; then
    log_debug "Removing cached APT packages"
    apt-get -q -o=Dpkg::Use-Pty=0 clean | log_trace "${_phase_apt}"
  else
    log_notice "Keeping cached packages because -k flag is set."
  fi

}

function _install_dependencies() {
  # Install packages mentioned in the arguments.
  # If installation fails exit the script.
  # ARG 1: Packages in quote separated by space.
  local packages=("$@")
  log_debug "Installing Packages ${packages[*]}"
  # Check if array is empty
  if [[ ${#packages[@]} -eq 0 ]]; then
    log_warn "Package array is empty!"
    return 19
  else
    apt-get -q -o=Dpkg::Use-Pty=0 -y --no-install-recommends install "${packages[@]}" 2>&1 | log_trace "${_phase_apt}"
    exit_status=$?
    if [ $exit_status -eq 0 ]; then
      log_success "Installed"
      _clean_apt_cache
      return 0
    else
      log_error "Failed to install dependencies: ${packages[*]}"
      log_error "Please see the log file for more details."
      return 21
    fi
  fi
}

function _install_pre_requisites() {
  # This function installs required packages for adding apt repositories
  # These should be present in your base Ubuntu install. If not present then, this function
  # will install them.
  # Following are the packages installed by this function:
  # linux-image-extra-<>, apt-transport-https, ca-certificates,
  # curl, software-properties-common
  local pre_requisite_packages=(apt-transport-https ca-certificates curl gnupg2)
  log_info "Installing necessary dependencies"
  if _install_dependencies "${pre_requisite_packages[@]}"; then
    log_debug "Installed dependencies"
  else
    log_and_exit "Dependency packages failed to install!" "21"
  fi

}

function _fix_repo_not_available() {
  # If repository is not available for latest Ubuntu release, this uses last stable release
  # (may not be LTS) for adding repository

  log_debug "Check and apply codename fixes"
  if [ "$bool_fix_repo_not_available_for_latest" == "true" ]; then
    # Check LTS fallback flag is being used
    # if running on current LTS, and fix mode is LTS fallback to last LTS.
    if [[ $bool_fix_repo_lts == "true" ]] && [[ $code_name == "${codename_current_lts}" ]]; then
      log_warn "Using Previous LTS release ::${codename_previous_lts}::"
      code_name="$codename_previous_lts"
      # note applied fix
      bool_codename_fix_appied="true"

    elif [[ $bool_fix_repo_lts != "true" ]] && [[ $code_name == "${codename_latest_release}" ]]; then
      log_warn "Using previous release ${codename_previous_release} as fallback"

      # fallback is non LTS so it might disapper/become unsupported! warn
      if [[ $codename_previous_release != "$codename_current_lts" ]]; then
        log_warn "Fallback Ubuntu (${codename_latest_release}) is a non LTS release!"
      fi
      code_name="$codename_previous_release"
      bool_codename_fix_appied="true"

    else
      log_warn "Not applicable."
      bool_codename_fix_appied="false"
    fi # lts
  else
    bool_codename_fix_appied="false"
    log_debug "Feature --fix/--fix-mode-lts is not available or disabled."
  fi # fix
}

function _warn_about_fix_codename() {
  log_warn "Repositories from older Ubuntu release are being used."
  log_warn "You need to modify this in Software and Updates,\n"
  log_warn "when they become available for ${codename_upcoming_release}${NC}\n"
}

function _fix_repo_not_available_upcoming_release() {
  # If repository is not available for upcoming  release, this uses last stable release
  # Aka if the pre-release release is 18.04 it might use 17.10 if used with --fix, it will use 18.04 repos.
  # With Debian If release is 11, when used with this flag we will use Debian 10 repos.
  # --fix is not valid in case of Debian, only --pre-release applies.

  log_debug "Check and apply codename fixes (--pre-release)"
  # check for fix-pre-release flag
  if [ "$bool_fix_repo_not_available_for_upcoming_release" == "true" ]; then

    if [[ $bool_fix_repo_lts == "true" ]] && [[ $code_name == "${codename_upcoming_release}" ]]; then
      log_warn "Using lastest Ubuntu LTS (${codename_current_lts}) as fallback!"
      code_name="${codename_current_lts}"
      bool_codename_fix_appied="true"

    elif [[ $bool_fix_repo_lts != "true" ]] && [[ $code_name == "${codename_upcoming_release}" ]]; then
      log_warn "Using lastest Ubuntu (${codename_latest_release}) as fallback!"
      code_name="${codename_latest_release}"
      bool_codename_fix_appied="true"

    elif [[ $code_name == "$codename_upcoming_debian_release" ]]; then
      log_dev "Pre-Release-Fix-Codename is experimental on Debian"
      log_warn "Using lastest Debian Stable (${codename_latest_debian_release}) as fallback!"

      code_name="${codename_latest_debian_release}"
      bool_codename_fix_appied="true"

    else
      log_warn "Not applicable."
      bool_codename_fix_appied="false"
    fi # check codenames

  else
    log_debug "Feature --pre-release is disabled."
    bool_codename_fix_appied="false"

  fi
}

function _map_to_obs_repos() {
  # This function maps code_name to OBS repos
  # This MUST be called AFTER code name fixes are applied.
  # but BEFORE adding any OBS repos
  log_debug "Mapping code_name to OBS prefix"

  # AE_OBS_PREFIX check
  if [[ -v ${AE_OBS_PREFIX} ]]; then
    log_and_exit "Reserved variable (AE_OBS_PREFIX) is set!" "66"
  fi

  # We dont need mint/elementary here because we dont use them as base anyway!
  case ${code_name} in
  # Ubuntu
  bionic) readonly AE_OBS_PREFIX="xUbuntu_18.04" ;;
  focal) readonly AE_OBS_PREFIX="xUbuntu_20.04" ;;
  groovy) readonly AE_OBS_PREFIX="xUbuntu_20.10" ;;
  hirsute) readonly AE_OBS_PREFIX="xUbuntu_21.04" ;;
  # Debian
  stretch) readonly AE_OBS_PREFIX="Debian_9" ;;
  buster) readonly AE_OBS_PREFIX="Debian_10" ;;
  bullseye) readonly AE_OBS_PREFIX="Debian_Testing" ;;
  *) log_and_exit "Internal Error in ${FUNCNAME[0]}, Failed to match AE_OBS_PREFIX for ${code_name}" "67" ;;

  esac

  log_var "code_name"
  log_var "AE_OBS_PREFIX"

}

function add_ppas() {
  # Function to add ppa by reading ppas from ppa.list of from YAML key config.ppa
  # List/Config file should contain ppas in following format
  # ppa:ppa:<author>/<ppa> for example, ppa:mozillateam/firefox-nex for adding firefox next/Beta PPA
  log_stage "Adding PPAs"
  local index
  local _ppa_dependencies=(apt-transport-https ca-certificates curl gnupg2 software-properties-common)
  # Function Reads the file ${dir}/data/ppa.index and adds the ppa one by one.
  # Install dependencies required
  if [ "$bool_is_debian" != "true" ]; then
    log_info "Installing dependencies"
    if _install_dependencies "${_ppa_dependencies[@]}"; then
      log_debug "Installed dependency packages: ${_ppa_dependencies[*]}"
    else
      log_error "Failed to install dependency packages for PPAs"
      log_error "PPAs cannot be installed with this error!"
      return 21
    fi

    for index in "${parsed_ppa_list[@]}"; do
      log_info "Setting up PPA - $index"
      # Check for empty lines
      if [ "$index" == "" ]; then
        log_debug "Found and empty entry, moving on to next"
        continue
      fi
      if add-apt-repository -y "$index" 2>&1 | log_trace "${_phase_ppa}"; then
        log_success "Success!"
      else
        log_error "Some error occured while adding $index.\n"
      fi
    done
  else
    log_error "This is Debian. PPAs are not available."
  fi

}

function add_repositories() {
  # This function adds repositories for several apps like
  # Google Chrome, Spotify, Google Cloud SDK, GCSFUSE(Part of google cloud),
  # Skype, Docker, Skype, Microsoft Visual Studio Code, Insync client, Wine-HQ etc
  # WARNING: Some repositories might not support latest version of Ubuntu.

  log_stage "Setting up repositories"

  AE_UMASK_PRE_HOOK="$(umask)"
  log_debug "Default UMASK is $AE_UMASK_PRE_HOOK"

  if [[ $AE_UMASK_PRE_HOOK != "0022" ]]; then
    log_notice "Setting UMASK to 0022 for the script to avoid APT errors"
    log_notice "This will be reverted at the end of this task."
    if ! umask 0022; then
      log_error "Failed to set UMASK to 0022 for task: Repositories"
      log_error "This may result in errors while updating repositories via packagekit"
    fi
  else
    log_debug "No need to modify UMASK"
  fi

  local exit_status
  local sources_list_bak_ts

  # shellcheck disable=SC2034
  declare -r MENDELEY_SOURCE_FILE_CONTENT="# This file lists the repositories for Mendeley Desktop.
#
# These repositories should work with most recent Debian/Ubuntu-based Linux
# distributions.
#
# If you have any problems with Mendeley's Debian/Ubuntu repositories,
# you can let us know at http://feedback.mendeley.com
#
# The distribution name sets the release channel you want to use,
# which can be either \"stable\" or \"preview\"

deb https://desktop-download.mendeley.com/download/apt stable main"

  # shellcheck disable=SC2034
  declare -r GOOGLE_CHROME_SOURCE_FILE_CONTENT="#  # # THIS FILE IS AUTOMATICALLY CONFIGURED ###
# You may comment out this entry, but any other modifications may be lost.
deb [arch=amd64] http://dl.google.com/linux/chrome/deb/ stable main"

  # install dependencies required
  _install_pre_requisites
  # if repository is not available for latest ubuntu release, use previous release
  # Be careful, things might not be compatible
  _fix_repo_not_available_upcoming_release
  _fix_repo_not_available

  # OBS
  _map_to_obs_repos

  # Backup sources.list if it will be modified
  if [[ $add_ubuntu_multiverse == "true" ]] || [[ $add_ubuntu_universe == "true" ]] ||
    [[ $add_ubuntu_restricted == "true" ]] || [[ $add_debian_contrib == "true" ]] ||
    [[ $add_debian_nonfree == "true" ]]; then
    log_warn "Configuration will modify etc/apt/sources.list"
    sources_list_bak_ts="$(date +'%Y%m%d-%H%M%S')"
    log_info "Backing up with suffix - ${sources_list_bak_ts}.ae.bak"
    if cp /etc/apt/sources.list "/etc/apt/sources.list.${sources_list_bak_ts}.ae.bak" 2>&1 | log_trace "${_phase_repo}"; then
      log_success "Backed up!"
    else
      log_and_exit "Failed to create backup of sources.list before modification!" "68"
    fi
  else
    log_debug "No need to backup sources.list!"
  fi

  # Ubuntu multiverse/universe/restricted
  if [[ ${distro_name} == "ubuntu" ]]; then

    # Universe - Community-maintained free and open-source software.
    if [[ ${add_ubuntu_universe} == "true" ]]; then
      log_info "Ubuntu/Universe"
      if add-apt-repository --yes universe 2>&1 | log_trace "${_phase_repo}"; then
        log_success "OK"
      else
        log_error "Failed to add Ubuntu/Universe reposiroty!"
      fi
    else
      log_debug "Skipped adding Ubuntu/Universe repository"
    fi

    # Restricted - Proprietary drivers for devices.
    if [[ ${add_ubuntu_restricted} == "true" ]]; then
      log_info "Ubuntu/Restricted"
      if add-apt-repository --yes restricted --yes 2>&1 | log_trace "${_phase_repo}"; then
        log_success "OK"
      else
        log_error "Failed to add Ubuntu/Restricted reposiroty!"
      fi
    else
      log_debug "Skipped adding Ubuntu/Restricted repository"
    fi

    # Multiverse - Software restricted by copyright or legal issues.
    if [[ ${add_ubuntu_multiverse} == "true" ]]; then
      log_info "Ubuntu/Multiverse"
      if add-apt-repository --yes multiverse 2>&1 | log_trace "${_phase_repo}"; then
        log_success "OK"
      else
        log_error "Failed to add Ubuntu/Multiverse reposiroty!"
      fi
    else
      log_debug "Skipped adding Ubuntu/Multiverse repository"
    fi

  else

    log_debug "Distro is not Ubuntu, skip adding ubuntu specific components!"
  fi # ubuntu check

  # Debian Additional repos
  if [[ ${distro_name} == "debian" ]]; then

    # Contrib
    if [[ ${add_debian_contrib} == "true" ]]; then
      log_info "Debian/Contrib"
      if add-apt-repository --yes contrib 2>&1 | log_trace "${_phase_repo}"; then
        log_success "OK"
      else
        log_error "Failed to add Debian/Contrib reposiroty!"
      fi
    else
      log_debug "Skipped adding Debian/Contrib repository"
    fi

    # Non-Free - Proprietary drivers for devices.
    if [[ ${add_debian_nonfree} == "true" ]]; then
      log_info "Debian/Non-Free"
      if add-apt-repository --yes non-free 2>&1 | log_trace "${_phase_repo}"; then
        log_success "OK"
      else
        log_error "Failed to add Debian/Non-Free reposiroty!"
      fi
    else
      log_debug "Skipped adding Debian/Non-Free repository"
    fi

  else
    log_debug "Distro is not Debian, skip adding debian specific components!"
  fi # debian check

  # AMD64 only
  if [ "$ARCH" != "amd64" ]; then
    log_warn "Google Chrome, Spotify, Mendeley, Signal and WineHQ are only supported on amd64 architecture!"
  else

    log_debug "Arch is 64 Bit. Enabled adding 64 bit repos."
    # 64 bit Only REPOS
    # Add Google Chrome
    if [ "$add_chrome_repo" == "true" ]; then
      log_info "Google Chrome"
      log_debug "Adding Google package signing Key"
      wget -q https://dl.google.com/linux/linux_signing_key.pub -O /tmp/ae/google_signing_key.pub >>$"$log_file"
      apt-key add /tmp/ae/google_signing_key.pub 2>&1 | log_trace "${_phase_apt_key}" ||
        log_error "Adding trusted keys for Google failed."
      if echo "${GOOGLE_CHROME_SOURCE_FILE_CONTENT}" >${SOURCES_FILE_DIR}/google-chrome.list; then
        log_success "OK"
      else
        log_error "Adding Google Chrome Repository failed"
      fi
    else
      log_debug "Skipped Google chrome repository"
    fi

    # Spotify client
    if [ "$add_spotify_repo" == "true" ]; then
      log_info "Spotify"
      __add_repo_keys --format "asc" \
        --file-prefix "spotify" \
        --key-url https://download.spotify.com/debian/pubkey_0D811D58.gpg

      if echo "deb [arch=$ARCH signed-by=${TRUSTED_KEYRINGS_DIR}/spotify.gpg] http://repository.spotify.com stable non-free #Spotify" >${SOURCES_FILE_DIR}/after-effects-spotify.list; then
        log_success "OK"
      else
        log_error "Adding Spotify Repository Failed"
      fi

    else
      log_debug "Skipped adding Spotify repository"
    fi

    # Skype
    if [ "$add_skype_repo" == "true" ]; then
      log_info "Skype"
      __add_repo_keys --format "asc" \
        --file-prefix "skype" \
        --key-url https://repo.skype.com/data/SKYPE-GPG-KEY

      if echo "deb [arch=$ARCH signed-by=${TRUSTED_KEYRINGS_DIR}/skype.gpg] https://repo.skype.com/deb stable main #Skype" >${SOURCES_FILE_DIR}/after-effects-skype.list; then
        log_success "OK"
      else
        log_error "Adding Skype for linux repository failed"
      fi

    else
      log_debug "Skipped Skype for Linux."
    fi

    # Signal App
    if [ "$add_signal_repo" == "true" ]; then
      log_info "Signal for Desktop"
      __add_repo_keys --format "asc" \
        --file-prefix "signal-desktop" \
        --key-url https://updates.signal.org/desktop/apt/keys.asc

      if echo "deb [arch=amd64 signed-by=${TRUSTED_KEYRINGS_DIR}/signal-desktop.gpg] https://updates.signal.org/desktop/apt xenial main #Signal-for-Desktop" >${SOURCES_FILE_DIR}/after-effects-signal.list; then
        log_success "OK"
      else
        log_error "Failed to addd Signal for desktop repository!"
      fi

    else
      log_debug "Skipped adding Signal for desktop repository"
    fi

    # Mendeley Desktop App
    if [ "$add_mendeley_repo" == "true" ]; then
      log_info "Mendeley desktop"
      apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 6F036044 2>&1 | log_trace "${_phase_apt_key}" ||
        log_error "Adding Mendeley Desktop Key Failed"

      # DO NOT RENAME THE FILE!
      if echo "${MENDELEY_SOURCE_FILE_CONTENT}" >${SOURCES_FILE_DIR}/mendeleydesktop.list; then
        log_success "OK"
      else
        log_error "Failed to add mendeley repository!"
      fi

    else
      log_debug "Skipped adding Mendeley repository"
    fi

    #Wine HQ
    if [ "$add_winehq_repo" == "true" ]; then
      log_info "WineHQ"
      if [[ ${code_name} == "focal" ]] || [[ ${code_name} == "groovy" ]] ||
        [[ ${code_name} == "hirsute" ]] || [[ ${code_name} == "bullseye" ]]; then
        __add_repo_keys --format "asc" \
          --file-prefix "wine-hq" \
          --key-url https://dl.winehq.org/wine-builds/winehq.key
        if echo "deb [signed-by=${TRUSTED_KEYRINGS_DIR}/wine-hq.gpg] https://dl.winehq.org/wine-builds/${distro_name}/ ${code_name} main #WineHQ" >${SOURCES_FILE_DIR}/after-effects-winehq.list; then
          log_success "OK"
        else
          log_error "Adding WineHQ repository failed"
        fi
      else
        log_error "Latest version of WINE depends on libfaudio0 package,"
        log_error "which is not available on your distribution!"
        log_warn "For more information visit https://forum.winehq.org/viewtopic.php?f=8&t=32192"
      fi
    else
      log_info "Skipped adding WineHQ."
    fi

  # End if ARCH==64 Check
  fi

  # Google Cloud SDK
  # shellcheck disable=SC2235
  if [[ $add_gcp_repo == "true" ]] || ([[ ${add_gcsfuse_repo} == "true" ]] && [[ ${ARCH} == "amd64" ]]); then
    log_debug "Adding GCP packaging keys"
    __add_repo_keys --format "gpg" \
      --file-prefix "google-cloud-packaging" \
      --key-url https://packages.cloud.google.com/apt/doc/apt-key.gpg
  else
    log_debug "Not adding Google cloud APT keys"
  fi

  # Google Cloud SDK
  if [ "$add_gcp_repo" == "true" ]; then
    log_info "Google-Cloud-SDK"
    if echo "deb [arch=$ARCH signed-by=${TRUSTED_KEYRINGS_DIR}/google-cloud-packaging.gpg] http://packages.cloud.google.com/apt cloud-sdk main #Google-Cloud-SDK" >${SOURCES_FILE_DIR}/after-effects-googlecloud.list; then
      log_success "OK"
    else
      log_error "Adding Google Cloud SDK Repository failed"
    fi
  else
    log_debug "Skipped adding Google Cloud SDK."
  fi

  # GCSFUSE
  if [ "$add_gcsfuse_repo" == "true" ]; then

    if [[ $ARCH == "amd64" ]]; then
      log_info "GCSFUSE"
      if echo "deb [arch=$ARCH signed-by=${TRUSTED_KEYRINGS_DIR}/google-cloud-packaging.gpg] http://packages.cloud.google.com/apt gcsfuse-${code_name} main #GCSFUSE" >${SOURCES_FILE_DIR}/after-effects-gcsfuse.list; then
        log_success "OK"
      else
        log_error "Adding GCSFUSE repository failed"
      fi
    else
      log_error "GCSFUSE is not supported on this architecture!"
    fi

  else
    log_debug "Skipped adding GCSFUSE"
  fi

  # Microsoft Keys
  # shellcheck disable=SC2235
  if ([[ $add_azurecli_repo == "true" ]] || [[ ${add_vscode_repo} == "true" ]] || [[ ${add_edge_repo} == "true" ]] || [[ ${add_msteams_repo} == "true" ]]) && [[ $ARCH == "amd64" ]]; then
    log_debug "Adding Microsoft keys."
    __add_repo_keys --format "asc" \
      --file-prefix "microsoft" \
      --key-url https://packages.microsoft.com/keys/microsoft.asc
  else
    log_debug "Both azurecli and vscode will not be added. So no need to add microsoft keys."
  fi

  # VSCode
  if [[ ${add_vscode_repo} == "true" ]]; then
    log_info "VSCode"
    if [[ ${ARCH} == "amd64" ]]; then
      if echo "deb [arch=$ARCH signed-by=${TRUSTED_KEYRINGS_DIR}/microsoft.gpg] https://packages.microsoft.com/repos/vscode stable main #Visual-Studio-Code" >${SOURCES_FILE_DIR}/after-effects-vscode.list; then
        log_success "OK"
      else
        log_error "Failed to addd VSCode repository!"
      fi
    else
      log_error "VSCode repositories are not supported on this architecture!($ARCH)"
      log_warn "Visit https://code.visualstudio.com/#alt-downloads"
    fi

  else
    log_debug "Skipped adding VSCode repository"
  fi

  # Azure cli
  if [[ ${add_azurecli_repo} == "true" ]]; then
    if [[ ${ARCH} == "amd64" ]]; then
      log_info "Azure CLI"
      if echo "deb [arch=$ARCH signed-by=${TRUSTED_KEYRINGS_DIR}/microsoft.gpg] https://packages.microsoft.com/repos/azure-cli/ ${code_name} main #Azure CLI" >${SOURCES_FILE_DIR}/after-effects-azurecli.list; then
        log_success "OK"
      else
        log_error "Failed to addd Azure CLI repository!"
      fi
    else
      log_error "Azure CLI cannot be installed via package manager on this architecture."
      log_warn "See https://docs.microsoft.com/en-us/cli/azure/install-azure-cli-linux?pivots=script"
    fi
  else
    log_debug "Skipped adding Azure CLI repository"
  fi

  # Microsoft Edge
  if [[ ${add_edge_repo} == "true" ]]; then
    if [[ ${ARCH} == "amd64" ]]; then
      log_info "Microsoft Edge"
      if echo "deb [arch=$ARCH signed-by=${TRUSTED_KEYRINGS_DIR}/microsoft.gpg] https://packages.microsoft.com/repos/edge stable main #Microsoft Edge" >${SOURCES_FILE_DIR}/after-effects-edge.list; then
        log_success "OK"
      else
        log_error "Failed to addd Microsoft Edge repository!"
      fi
    else
      log_error "Microsoft Edge is not supported on this architecture($ARCH)!"
    fi
  else
    log_debug "Skipped adding Microsoft Edge repository"
  fi

  # Microsoft Teams
  if [[ ${add_msteams_repo} == "true" ]]; then
    if [[ ${ARCH} == "amd64" ]]; then
      log_info "Microsoft Teams"
      if echo "deb [arch=$ARCH signed-by=${TRUSTED_KEYRINGS_DIR}/microsoft.gpg] https://packages.microsoft.com/repos/ms-teams stable main #Microsoft Edge" >${SOURCES_FILE_DIR}/after-effects-teams.list; then
        log_success "OK"
      else
        log_error "Failed to addd Microsoft Teams repository!"
      fi
    else
      log_error "Microsoft Teams is not supported on this architecture($ARCH)!"
    fi
  else
    log_debug "Skipped adding Microsoft Teams repository"
  fi

  # Docker CE
  if [ "$add_docker_repo" == "true" ]; then
    log_info "Docker-CE"
    __add_repo_keys --format "asc" \
      --file-prefix "docker-ce" \
      --key-url https://download.docker.com/linux/"${distro_name}"/gpg
    log_debug "Adding Docker(Docker Inc) sources .list"

    if echo "deb [arch=$ARCH signed-by=${TRUSTED_KEYRINGS_DIR}/docker-ce.gpg] https://download.docker.com/linux/${distro_name}  ${code_name} stable #Docker-Community-Edition" >${SOURCES_FILE_DIR}/after-effects-docker.list; then
      log_success "OK"
    else
      log_error "Adding Docker-CE repository failed"
    fi

  else
    log_debug "Skipped Docker-CE"
  fi

  # Github CLI
  #gh

  if [ "$add_gh_repo" == "true" ]; then
    log_info "GitHub CLI"
    # TODO: Waiting for fix https://github.com/cli/cli/issues/3513 to use keys directly.
    apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C99B11DEB97541F0 2>&1 | log_trace "${_phase_apt_key}" ||
      log_error "Adding Github CLI keys failed"

    if echo "deb https://cli.github.com/packages  ${code_name}  main #GitHub-CLI" >${SOURCES_FILE_DIR}/after-effects-github.list; then
      log_success "OK"
    else
      log_error "Adding GH CLi repository failed"
    fi

  else
    log_debug "Skipped GitHub CLI(gh)."
  fi

  # Hashicorp
  if [ "$add_hashicorp_repo" == "true" ]; then
    if [ "$ARCH" == "amd64" ]; then
      log_info "Hashicorp"
      __add_repo_keys --format "asc" \
        --file-prefix "hashicorp" \
        --key-url https://apt.releases.hashicorp.com/gpg

      if echo "deb [arch=amd64 signed-by=${TRUSTED_KEYRINGS_DIR}/hashicorp.gpg] https://apt.releases.hashicorp.com ${code_name} main#Hashicorp-Packages" >${SOURCES_FILE_DIR}/after-effects-hashicorp.list; then
        log_success "OK"
      else
        log_error "Failed to add hashicorp repository"
      fi

    else
      log_error "Hashicorp repository is not supported on this architecture($ARCH)!"
    fi
  else
    log_debug "Skipped adding Hashicorp repository"
  fi

  # Bazel
  if [[ ${add_bazel_repo} == "true" ]]; then
    if [ "$ARCH" == "amd64" ]; then
      log_info "Bazel"
      __add_repo_keys --format "asc" \
        --file-prefix "bazel" \
        --key-url https://bazel.build/bazel-release.pub.gpg

      if echo "deb [arch=amd64 signed-by=${TRUSTED_KEYRINGS_DIR}/bazel.gpg] https://storage.googleapis.com/bazel-apt stable jdk1.8 #Bazel" >${SOURCES_FILE_DIR}/after-effects-bazel.list; then
        log_success "OK"
      else
        log_error "Failed to add bazel repository"
      fi

    else
      log_error "Bazel repository is not supported on this architecture($ARCH)!"
    fi
  else
    log_debug "Skipped adding Bazel repository"
  fi

  # gVisor container Runtime
  if [[ $add_gvisor_repo == "true" ]]; then

    if [[ $ARCH == "amd64" ]]; then
      log_info "gVisor"

      # Adding gVisor Keys
      __add_repo_keys --format "asc" \
        --file-prefix "gvisor" \
        --key-url https://gvisor.dev/archive.key

      if echo "deb [arch=$ARCH signed-by=${TRUSTED_KEYRINGS_DIR}/gvisor.gpg] https://storage.googleapis.com/gvisor/releases release main #gVisor-Container-Runtime" >${SOURCES_FILE_DIR}/after-effects-gvisor.list; then
        log_success "OK"
      else
        log_error "Adding gVisor repository failed!"
      fi

    else
      log_error "gVisor is not supported on this architecture(${ARCH})"
      log_dev "Visit https://gvisor.dev/ for more info"
    fi

  else
    # gVisor is not enabled
    log_debug "Skipped addinng gVisor repository."
  fi

  # Podman via OBS
  if [[ ${add_podman_repo} == "true" ]]; then

    if [[ ${ARCH} == "amd64" ]] && [[ $distro_name == "ubuntu" ]]; then

      log_info "Podman"
      __add_repo_keys --format "asc" \
        --file-prefix "obs-podman-${code_name}" \
        --key-url https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/${AE_OBS_PREFIX}/Release.key
      if echo "deb [arch=$ARCH signed-by=${TRUSTED_KEYRINGS_DIR}/obs-podman-${code_name}.gpg] https://download.opensuse.org/repositories/devel:/kubic:/libcontainers:/stable/${AE_OBS_PREFIX}/ / #Podman (via OBS)" >${SOURCES_FILE_DIR}/after-effects-podman.list; then
        log_success "OK"
      else
        log_error "Adding Podman repository failed!"
      fi

    else
      log_error "Podman is not supported on ${AE_DISTRO_NAME}/${ARCH}"
      if [[ ${distro_name} == "debian" ]]; then
        log_warn "Podman depends on libseccomp2 from backports repository."
        log_warn "See https://podman.io/getting-started/installation."
      fi
    fi

  else
    # Podman is not enabled
    log_debug "Skipped addinng Podman repository."
  fi

  # Sublime Text
  if [ "$add_sublimetext_repo" == "true" ]; then
    if [ "$ARCH" == "amd64" ]; then
      log_info "SublimeText"
      __add_repo_keys --format "asc" \
        --file-prefix "sublimetext" \
        --key-url https://download.sublimetext.com/sublimehq-pub.gpg

      if echo "deb [arch=amd64 signed-by=${TRUSTED_KEYRINGS_DIR}/sublimetext.gpg] https://download.sublimetext.com/ apt/stable/ #SublimeText Editor" >${SOURCES_FILE_DIR}/after-effects-sublimetext.list; then
        log_success "OK"
      else
        log_error "Failed to add SublimeText repository"
      fi

    else
      log_error "SublimeText repository is not supported on this architecture($ARCH)!"
    fi
  else
    log_debug "Skipped adding SublimeText repository"
  fi

  # ROS2
  # Arch support varies on distro so lot of ugly elifs.
  ros2_supported="false"

  if [[ $add_ros2_repo == "true" ]] && [[ ${bool_codename_fix_appied} == "true" ]]; then
    log_info "ROS2"
    log_error "You have enabled --fix or --pre-release option."
    log_error "ROS2 depends heavily on packages included in the distribution."
    log_error "ROS2 repositories will not be added for sanity of your system!"

  elif [[ $add_ros_repo == "true" ]] && [[ ${bool_codename_fix_appied} == "false" ]]; then

    log_info "ROS2"

    # Distro/Version/Arch checks
    if [[ $distro_name == "ubuntu" ]]; then
      if [[ $code_name == "focal" ]]; then
        ros2_supported="true"
        log_success "ROS2 is available on focal/$ARCH"
      fi
    fi #ubuntu

    if [[ $ros2_supported == "true" ]]; then
      log_info "Adding ROS2 repositories"
      log_debug "Adding ROS2 repo key"
      __add_repo_keys --format "asc" \
        --file-prefix "ros2" \
        --key-url https://raw.githubusercontent.com/ros/rosdistro/master/ros.asc

      if echo "deb [arch=$ARCH signed-by=${TRUSTED_KEYRINGS_DIR}/ros2.gpg]  http://packages.ros.org/ros2/ubuntu ${code_name} main #ROS-Repository" >$SOURCES_FILE_DIR/ros2.list; then
        log_success "OK"
      else
        log_error "Adding ROS repository failed!"
      fi

    else
      log_error "ROS2 is not supported on this distro/release!"
    fi # ros_arch_supported

  else
    log_debug "Skipped ROS2"
  fi # add_ros_repo

  # ROS
  # Arch support varies on distro so lot of ugly elifs.
  ros_arch_supported="false"

  if [[ $add_ros_repo == "true" ]] && [[ ${bool_codename_fix_appied} == "true" ]]; then
    log_info "ROS"
    log_error "You have enabled --fix or --pre-release option."
    log_error "ROS depends heavily on packages included in the distribution."
    log_error "ROS repositories will not be added for sanity of your system!"

  elif [[ $add_ros_repo == "true" ]] && [[ ${bool_codename_fix_appied} == "false" ]]; then

    log_info "ROS"

    # Distro/Version/Arch checks
    if [[ $distro_name == "ubuntu" ]]; then
      if [[ $code_name == "bionic" ]]; then
        ros_arch_supported="true"
        log_success "ROS is available on Bionic/$ARCH"
      elif [[ $code_name == "xenial" ]]; then
        ros_arch_supported="true"
        log_success "ROS is available on Xenial/$ARCH"
      elif [[ $code_name == "focal" ]]; then
        ros_arch_supported="true"
        log_success "ROS is available on Focal/$ARCH"
      fi
    fi #ubuntu

    if [ "$distro_name" == "debian" ]; then
      # Check architectures
      if [[ $code_name == "stretch" ]] || [[ $code_name == "buster" ]]; then
        ros_arch_supported="true"
        log_success "ROS is available on Debian ${code_name}/$ARCH"
      fi
    fi #debian

    if [[ $ros_arch_supported == "true" ]]; then
      log_info "Adding ROS repositories"
      log_debug "Adding ROS repo key (latest)"
      apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654 2>&1 | log_trace "${_phase_apt_key}" ||
        log_error "Adding ROS repository key failed!"

      if [[ $bool_use_uf_mirror == "true" ]]; then
        log_warn "UF ROS Repo is no loger syncing with upstream."
        log_warn "This feature will be enabled once the mirror is back in sync!"
        log_warn "Till then, upstream is being used!"
      fi

      if echo "deb http://packages.ros.org/ros/ubuntu ${code_name} main #ROS-Repository" >$SOURCES_FILE_DIR/ros.list; then
        log_success "OK"
      else
        log_error "Adding ROS repository failed!"
      fi

    else
      log_error "ROS is not supported on this distro!"
    fi # ros_arch_supported

  else
    log_debug "Skipped ROS"
  fi # add_ros_repo

  # Reset UMASK if not 0022
  if [[ $AE_UMASK_PRE_HOOK != "0022" ]]; then
    log_notice "Setting UMASK back to $AE_UMASK_PRE_HOOK"
    if ! umask "$AE_UMASK_PRE_HOOK"; then
      log_error "Failed to set UMASK back to $AE_UMASK_PRE_HOOK"
    fi
  else
    log_debug "No need to modify UMASK (post-task-hook)"
  fi

  update_repos

}

function __fix_permissions() {

  # Fix permissions
  # Expects 2 args
  # Arg 1 : Path to check
  # Arg 2 : Permission in octal

  local check_path expected_permissions
  local path_attrs

  if [[ $# -lt 2 ]]; then
    log_and_exit "Internal Error in ${FUNCNAME[0]}, expected 2 args, got $#" "19"
  fi

  check_path="${1}"
  expected_permissions="${2}"

  # check if pat exists
  if [[ ! -e ${check_path} ]]; then
    log_error "Internal Error in ${FUNCNAME[0]}, path(${check_path}) not found!"
    # immediately return
    return
  fi

  # check if attributes are valid
  if [[ ! ${expected_permissions} =~ ^[4-7][04-7][04-7]$ ]]; then
    log_error "Expected permissions are invalid(${expected_permissions})"
    log_and_exit "Internal Error! in ${FUNCNAME[0]}" "19"
  fi

  # check permissions and fix it
  path_attrs="$(stat -L -c %a "${check_path}")"
  if [[ ${path_attrs} != "${expected_permissions}" ]]; then
    log_warn "${check_path} has INCORRECT permissions(${path_attrs})!"
    if chmod "${expected_permissions}" "${check_path}" 2>&1 | log_trace "${_phase_apt_key}"; then
      log_success "Fixed!"
    else
      log_error "Failed to fix permissions!"
      # immediately return
      return
    fi
  else
    log_debug "${check_path} has expected permissions(${expected_permissions})."
  fi
}

function __add_repo_keys() {
  if [[ $# -ne 6 ]]; then
    log_and_exit "Internal Error! Expected 6 args (got $#) for ${FUNCNAME[0]}!" "19"
  fi

  local exit_code
  local key_url key_file_prefix key_format

  while [ "${1}" != "" ]; do
    case ${1} in
    -k | --key-url)
      shift
      key_url="${1}"
      ;;
    -p | --file-prefix)
      shift
      key_file_prefix="${1}"
      ;;
    -f | --format)
      shift
      key_format="${1}"
      ;;
    *)
      log_and_exit "Invalid internal function arguments for ${FUNCNAME[0]}!" "19"
      ;;
    esac
    shift
  done

  log_property "Key file URL" "${key_url}"
  log_property "Key file Format" "${key_format}"
  log_property "Key file name" "${key_file_prefix}.${key_format}"

  # check if format is valid
  if [[ ! ${key_format} =~ ^(gpg|asc)$ ]]; then
    log_and_exit "Internal Error in ${FUNCNAME[0]} -f/--format can only accept gpg or asc[${key_format}]/" "19"
  fi

  # check if file prefix is valid
  # shellcheck disable=SC1001
  if [[ ! ${key_file_prefix} =~ ^[a-zA-Z][a-zA-Z.\-]+[a-zA-Z0-9]$ ]]; then
    log_and_exit "Internal Error in ${FUNCNAME[0]}  --file-prefix is invalid!" "19"
  fi

  if [[ ! ${key_url} =~ ^https:// ]]; then
    log_error "APT Key URL does not start with https://."
    log_error "Got (${key_url})!"
    log_and_exit "Internal Error in ${FUNCNAME[0]} APT key URL is invalid!" "19"
  fi

  # check if ${TRUSTED_KEYRINGS_DIR} is present
  if [[ ! -d ${TRUSTED_KEYRINGS_DIR} ]]; then
    log_error "${TRUSTED_KEYRINGS_DIR} is missing!!"
    log_and_exit "Your installation of ${AE_DISTRO_NAME} is broken!" "64"
  fi

  # fetch key
  if [[ -e ${TRUSTED_KEYRINGS_DIR}/${key_file_prefix}.gpg ]]; then
    log_warn "GPG Key file ${key_file_prefix}.${key_format} already exists!"
    log_warn "Script will *NOT* overwrite it to avoid deleting keys!"
  else
    log_debug "Fetching key"

    curl -sSfL -m 20 -o "${TRUSTED_KEYRINGS_DIR}/${key_file_prefix}.${key_format}" "${key_url}" 2>&1 | log_trace "${_phase_apt_key}"
    exit_code="$?"
    if [[ $exit_code -eq 0 ]]; then
      log_debug "OK"
    else
      log_error "Failed to fetch keys from ${key_url}!"
    fi
  fi

  # check if file has correct permissions
  __fix_permissions "${TRUSTED_KEYRINGS_DIR}/${key_file_prefix}.${key_format}" "644"

  # check if file needs to be converted
  if [[ ${key_format} == "asc" ]]; then

    log_debug "Key is in ascii armored format. Converting it."
    if [[ -e "${TRUSTED_KEYRINGS_DIR}/${key_file_prefix}.gpg" ]]; then
      log_warn "Dearmored file already exists!"
      log_warn "Script will *NOT* overwrite it to avoid deleting keys."
    else
      gpg --dearmor --output "${TRUSTED_KEYRINGS_DIR}/${key_file_prefix}.gpg" "${TRUSTED_KEYRINGS_DIR}/${key_file_prefix}.asc" 2>&1 | log_trace "${_phase_apt_key}"
      exit_code="$?"
      if [[ $exit_code -eq 0 ]]; then
        log_debug "Successfully converted ascii armored GPG key file."
      else
        log_error "Failed to convert ascii armored GPG key file."
      fi
    fi

    # check and fix permissions
    __fix_permissions "${TRUSTED_KEYRINGS_DIR}/${key_file_prefix}.gpg" "644"

  else
    log_debug "No need to convert key file."
  fi

}

function update_repos() {
  local exit_status
  log_info "Running apt-get update"
  apt-get -q -o=Dpkg::Use-Pty=0 update 2>&1 | log_trace "${_phase_apt}"
  exit_status=$?
  if [[ $exit_status -eq 0 ]]; then
    log_success "Success!"
  else
    log_error "Command apt-get update failed and exited with ${exit_status}"
    log_error "In most cases its either missing repo keys or wrongly configured repositories."
    log_error "Fix then and re run the script."
    log_and_exit "The script cannot proceed with this error." "61"
  fi
}

function update_repos_as_task() {
  log_stage "Update repository metadata"
  update_repos
}

function upgrade_apps() {
  # This function will list up-gradable apps and upgrade it.
  # IF Simulate is set to true this will only list the apps but no upgrade action will be performed.
  local exit_status
  log_stage "Upgrade Packages"
  log_info "Checking and upgrading packages"
  # upgradable is not available in apt-get ignore warning about apt being unstable
  apt list --upgradable 2>&1 | log_trace "${_phase_apt}" ||
    log_info "Something went wrong while listing upgradable packages. Please see the log file or run in debug mode for details."

  # only do upgrades if simulate is set to false
  if [ "$simulate_apt_install" != "true" ]; then

    DEBIAN_FRONTEND=noninteractive apt-get -q -o=Dpkg::Use-Pty=0 -y upgrade 2>&1 | log_trace "${_phase_apt}"
    DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" --allow-remove-essential --allow-change-held-packages -fuy dist-upgrade |
      log_trace "${_phase_apt}"
    exit_status=$?
  else
    # If  simulate is true, set exit status as 0
    # Simulate flag skips the section above. No point in Checking for exit status
    log_warn "Simulate is set to True. Not performing upgrade!"
    exit_status=0
  fi
  if [[ $exit_status -eq 0 ]]; then
    log_success "Completed"
  else
    log_error "Something went wrong while upgrading packages."
    log_error "Please see the log file for more details."
    log_error "Most of the times its either missing keys or wrongly configured repositories."
  fi
  # Cleanup APT cache (-k)
  _clean_apt_cache

}

function upgrade_system() {
  log_stage "Update repository index/metadata "
  update_repos
  upgrade_apps
}

function purge_not_required() {
  # This function purges not required packages from the list ${dir}/data/purge.list
  # A flag -d MUST be passed for this option to work
  # Not passing a flag and choosing purge will result in error and action being aborted.
  # Simulate is not properly tested and use it with caution!
  # Combination of simulate and purge is UNSTABLE
  # You can modify -d requirement by setting the d_flag_passed=true
  # No validation/checks are done on the list file.
  # Action is dangerous if used carelessly eg. If you are stupid and remove say sudo (why would you??)

  local exit_status
  if [ "$bool_purge_pkgs" == "true" ]; then
    log_stage "Purging packages"

    if [[ ${#parsed_purge_packages[@]} -eq 0 ]]; then
      log_error "Packages to purge is empty!"
      return
    else
      if [ "$simulate_apt_install" == "true" ]; then
        log_warn "SIM - using --dry-run"
        apt-get -q -o=Dpkg::Use-Pty=0 -y remove --purge --dry-run "${parsed_purge_packages[@]}" 2>&1 | log_trace "${_phase_apt}"
      else
        apt-get -q -o=Dpkg::Use-Pty=0 -y purge "${parsed_purge_packages[@]}" 2>&1 | log_trace "${_phase_apt}"
      fi
      exit_status=$?

      if [[ $exit_status -eq 0 ]]; then
        log_success "Done!"
      else
        log_error "Something went wrong while purging packages."
        log_error "Please see the log file for more details."
      fi
    fi

  else
    log_and_exit "Purge switch is set to false. Did you pass -d along with the command?" "20"
  fi

}

function install_apps() {
  # Function to install apps mentioned in arrays
  # external-repos should always be at last to avoid any errors in previous .
  # No checks are being made on any of the files for validity. One entry per line is recommended.
  # If a package is not available entire collection in the file *.list will not be installed!!

  log_stage "Install packages"
  update_repos

  echo ttf-mscorefonts-installer msttcorefonts/accepted-mscorefonts-eula select true | debconf-set-selections
  #Install starts here
  local packages exit_status index
  #shellcheck disable=SC2034
  readonly local package_arrays=(
    administration
    security
    productivity
    multimedia
    development
    other
    external
  )
  for array in "${package_arrays[@]}"; do
    local apt_extra_args=()
    case "${array}" in
    administration) packages=("${parsed_administration_packages[@]}") ;;
    security) packages=("${parsed_secutity_packages[@]}") ;;
    productivity) packages=("${parsed_productivity_packages[@]}") ;;
    multimedia) packages=("${parsed_multimedia_packages[@]}") ;;
    development) packages=("${parsed_development_packages[@]}") ;;
    other) packages=("${parsed_other_packages[@]}") ;;
    external) packages=("${parsed_external_packages[@]}") ;;
    *) log_and_exit "Internal error. Invalid array type" "19" ;;
    esac

    # Chek if array is empty
    if [[ ${#packages[@]} -eq 0 ]]; then
      log_debug "Ignoring empty list of packages in $array"
      continue
    else
      log_info "Installing $array packages"
      # Check if simulate is true
      if [ "$simulate_apt_install" == "true" ]; then
        log_warn "SIM - Using --dry-run"
        apt_extra_args+=("--dry-run")
      fi

      apt-get -q -o=Dpkg::Use-Pty=0 -y install "${apt_extra_args[@]}" "${packages[@]}" | log_trace "${_phase_apt}"

      exit_status=$?
      unset packages
      if [[ $exit_status -eq 0 ]]; then
        log_success "Done!"
      else
        log_error "Something went wrong while installing packages in set - $array."
        log_error "Please see the log file for more details."
      fi

    fi
    unset packages
  done
  # Delete DEBs
  _clean_apt_cache

}

function install_debs() {

  # Function to get the deb files from DEB_URL in the ${dir}/data/deb_files.list
  # The list file has following format
  # URL to get the deb file  <space or tab> NAME_OF_THE_APP(without spaces)

  log_stage "Install DEB packages"
  local index deb_url line deb_file_name
  local exit_status
  log_debug "Option: Install DEB Files, Function name: install_debs"
  for index in "${parsed_deb_files_list[@]}"; do
    deb_url=$(echo "$index" | cut -d ',' -f1)
    deb_file_name=$(echo "$index" | cut -d ',' -f2)
    log_var "deb_url"
    log_var "deb_file_name"

    if [[ -z $deb_url ]] || [[ -z $deb_file_name ]]; then
      log_error "Malformed entry either URL or name is empty!"
      continue
    fi

    log_property "Downloading" "$deb_file_name" "1"
    {
      wget -q "$deb_url" -O "${deb_file_name}" >>"$log_file"
    } ||
      {
        log_error "Failed!"
        continue
      }

    log_property "Installing" "$deb_file_name" "1"
    # Check if simulate is true
    if [ "$simulate_apt_install" == "true" ]; then
      log_warn "SIM - $deb_file_name Installation!!"
      dpkg -i --dry-run "$deb_file_name" 2>&1 | log_trace "${_phase_deb}"

      log_debug "Installing missing packages"
      apt-get -q -o=Dpkg::Use-Pty=0 -y install -f 2>&1 | log_trace "${_phase_apt}"
      exit_status=$?
    else
      dpkg -i "$deb_file_name" 2>&1 | log_trace "${_phase_deb}"
      log_debug "Installing missing packages"
      apt-get -q -o=Dpkg::Use-Pty=0 -y install -f 2>&1 | log_trace "${_phase_apt}"
      exit_status=$?
    fi

    # shellcheck disable=SC2181
    if [ "$exit_status" = "0" ]; then
      log_success "Done"
    else
      log_error "Some error occurred during downloading and installing $index."
    fi
    # Delete DEBs
    if [ "$bool_preserve_debs" == "false" ]; then
      log_debug "Clean up downloaded packages"
      (
        rm -f "${dir}/${deb_file_name}" >>"$log_file"
      )
    else
      log_notice "Keeping downloaded packages"
    fi
  done

  _clean_apt_cache

}

function install_binaries() {

  # Function to get the binaries files from URL in the ${dir}/data/bin.list
  # The list file has following format
  # <URL>,<filename>
  # If you want to specify relative path you
  # can do so relative to /usr/local/bin
  # Be careful not to rename existing ones
  log_stage "Install static binaries"

  local index bin_url line bin_name
  local exit_status
  log_debug "Option: Install static binaries, Function name: install_binaries"
  # Check if simulate is true
  for index in "${parsed_bin_packages[@]}"; do
    bin_url=$(echo "$index" | cut -d ',' -f1)
    bin_name=$(echo "$index" | cut -d ',' -f2)
    log_var "bin_url"
    log_var "bin_name"

    if [[ -z $bin_url ]] || [[ -z $bin_name ]]; then
      log_error "Malformed entry either URL or name is empty!"
      continue
    fi
    log_info "Downloading - $bin_name"
    wget -q "$bin_url" -O "/tmp/ae/${bin_name}" >>"$log_file"
    exit_status="$?"
    if [ $exit_status -eq 0 ]; then
      log_success "OK"
      log_info "Installing  - $bin_name"
      if [ "$simulate_apt_install" == "true" ]; then
        log_warn "SIM - Skipping install"
      else
        {
          cp -rf "/tmp/ae/${bin_name}" /usr/local/bin/"${bin_name}"
        } || log_error "Failed to copy $bin_name"
        log_debug "Setting Permissions"
        chmod +x /usr/local/bin/"$bin_name" >>"${log_file}"
      fi
    else
      log_error "Failed to download $bin_name."
    fi
  done

}

function __install_snaps() {
  #Install Snap packages
  local exit_status index snapd_options
  local snap_type
  snap_type="$1"

  case ${snap_type} in
  classic)
    snapd_options=("--color=never" "--classic")
    parsed_snaps_list=("${parsed_snap_classic_packages[@]}")
    ;;
  edge)
    snapd_options=("--color=never" "--edge")
    parsed_snaps_list=("${parsed_snap_edge_packages[@]}")
    ;;
  normal)
    snapd_options=("--color=never")
    parsed_snaps_list=("${parsed_snap_normal_packages[@]}")
    ;;
  *) log_and_exit "Internal Function Error. Arguments for snap type." "19" ;;
  esac

  if [[ ${#parsed_snaps_list[@]} -eq 0 ]]; then
    log_warn "Snaps array is empty!" "19"
  else
    for index in "${parsed_snaps_list[@]}"; do
      log_info "Installing snap - $index"
      if [ "$index" == "" ] || [ "$index" == " " ]; then
        log_warn "Found an empty entry, Ignoring"
        continue
      fi

      if [ "$simulate_apt_install" == "true" ]; then
        log_warn "SIM - skipping installation"
      else
        log_debug "Options are ${snapd_options[*]}"
        if snap install "${snapd_options[@]}" "$index" 2>&1 | log_trace "${_phase_snap}"; then
          log_success "$line installed successfully."
        else
          log_error "Failed!"
        fi
      fi
    done
  fi
}

function install_snaps() {
  local dependency_packages
  dependency_packages=(snapd)

  log_stage "Install snap packages"

  if [ "$simulate_apt_install" == "true" ]; then
    log_warn "SIM - Skipped installing dependencies!"
  else
    if [[ -f /etc/apt/preferences.d/nosnap.pref ]] && [[ $AE_SNAP_REMOVE_APT_BLOCK == "true" ]]; then
      log_notice "Removing APT preferences which block snapd install"
      if rm /etc/apt/preferences.d/nosnap.pref; then
        log_success "Snapd is instalable again"
      else
        log_error "Failed to remove APT block on snapd package (LinuxMint-Ovrride)"
        log_error "Snap packages cannot be installed!"
        return 21
      fi
    fi

    log_info "Install dependencies"
    if _install_dependencies "${dependency_packages[@]}"; then
      log_debug "Installed dependency packages: ${dependency_packages[*]}"
    else
      log_error "Failed to install dependency packages for snaps"
      log_error "Snaps cannot be installed with this error!"
      return 21
    fi

  fi # simulate check

  log_stage "Install snap packages (default confinement)"
  __install_snaps "normal"
  log_stage "Install snap packages (classic confinement)"
  __install_snaps "classic"
  log_stage "Install snap packages (beta)"
  __install_snaps "edge"

}

function _autopilot_check_task_flag_and_run() {
  # checks flags set for each task/function and runs it
  # Arguments Two
  # ARG -1 : global flag variable to check
  # ARG -2: Function Name to execute
  local flag=${1}
  local runnable=${2}

  if [ "${flag}" == "true" ]; then
    log_debug "Executing Function $runnable"
    "$runnable"
  else
    log_debug "Task : $runnable is not enabled"
  fi
  unset runnable
}

function all_in_one() {
  #Wrapper for all options
  log_debug "Option: ALL IN ONE, function name: all_in_one"
  update_repos_as_task
  upgrade_apps
  add_ppas
  add_repositories
  install_apps
  install_debs
  purge_not_required
  install_binaries
  install_snaps

}

function _prompt_confirmation() {
  # Function to confirm whether action selected should be performed or not.
  # Accepts 2 arguments
  # ARG-2 Message to be displayed in confirmation box
  # ARG-2 name of the function to execute
  # Depends on whiptail
  # To overide and say yes to all dialog pass -y as command line option while running the script.
  local confirm_msg="${1}"   #Message shown in Confirmation dialogue
  local exec_function="${2}" #Function to run if user selected yes
  COLUMNS=$(tput cols)
  LINES=$(tput lines)
  export COLUMNS LINES
  if [[ ${AE_AUTOPILOT} == "true" ]]; then
    log_debug "Yes to all: No confirm dialog to be displayed."
    log_debug "Executing: $exec_function"
    $exec_function
  else
    log_debug "Confirming  $exec_function."
    # shellcheck disable=SC2086
    if (whiptail --title "Ubuntu Post-Install Script" --yesno "$confirm_msg" $LINES $COLUMNS $((LINES - 12))); then
      # execute the function
      log_debug "Executing: $exec_function"
      $exec_function
    else
      log_debug "Selected No for $name_of_task, Returning to main menu."
      _process_menu
    fi
  fi
  unset exec_function
}

function _process_menu() {
  local whiptail_exitstatus task COLUMNS LINES
  log_debug "Displaying Main menu"
  COLUMNS=$(tput cols)
  LINES=$(tput lines)
  #export COLUMNS LINES
  # shellcheck disable=SC2086
  task=$(whiptail \
    --notags \
    --backtitle "$SCRIPT" \
    --title "Ubuntu Post-Install Script" \
    --menu "\nWhat would you like me to do?" \
    --cancel-button "Quit" \
    $LINES $COLUMNS $((LINES - 12)) \
    update 'Update Repository Metadata' \
    upgrade 'Upgrade Packages' \
    repo 'Add Repositories' \
    ppas 'Add PPAs' \
    apps 'Install APT Packages' \
    debs 'Install DEB packages' \
    bin 'Install static binaries' \
    snaps 'Install snap packages' \
    purge 'Purge not required packages' \
    all 'All the tasks mentioned above' \
    3>&1 1>&2 2>&3)

  __menu_info_add_repo="
  Settings for additional repositories is set as follows.
  -------------------------------------------------------

  Docker Community Edition     : $add_docker_repo
  GitHub CLI                   : $add_gh_repo
  Google - Bazel               : $add_bazel_repo
  Google - Chrome              : $add_chrome_repo
  Google Cloud - SDK           : $add_gcp_repo
  Google Cloud - GCSFUSE       : $add_gcsfuse_repo
  Google Cloud - gVisor        : $add_gvisor_repo
  Hashicorp Packages           : $add_hashicorp_repo
  Mendeley for Desktop         : $add_mendeley_repo
  Microsoft - Azure CLI        : $add_azurecli_repo
  Microsoft - Edge             : $add_edge_repo
  Microsoft - Skype            : $add_skype_repo
  Microsoft - Teams            : $add_msteams_repo
  Microsoft - VSCode           : $add_vscode_repo
  Podman (via from Kubic OBS)  : $add_podman_repo
  ROS                          : $add_ros_repo
  ROS2                         : $add_ros2_repo
  Signal for Desktop           : $add_signal_repo
  SublimeText Editor           : $add_sublimetext_repo
  ----------------- Only Applied on Ubuntu --------------
  Multiverse                   : $add_ubuntu_multiverse
  Universe                     : $add_ubuntu_universe
  Restricted                   : $add_ubuntu_restricted
  ----------------- Only Applied on Debian --------------
  Non-Free                     : $add_debian_contrib
  Contrib                      : $add_debian_contrib



  Proceed with adding these repositories?

  "

  __menu_info_upgrade="
  This action will upgrage already installed packages on your system.

  Please pin package versions to avoid them from being automatically
  updated.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_update="
  This action will update repository metadata. This action
  will simple run apt-get update as root.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_ppa="
  This action will add PPAs from the config to your system.
  Some dependency packages like curl and software-properties
  might get installed to enable adding these PPAs.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_apps="
  This action will install packages defined in your config.
  As there might be hundreds of packages they are not displayed
  here. Please ensure that packages are valid and are available
  on your distribution. This might take some time depending on
  your Internet connection and CPU.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_purge="
  This action can remove packages which come
  preinstalled on Ubuntu/Debian installation.
  Use this with caution! Removing a core dependency might
  lead t a broken system!
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_all="
  This will run ALL the tasks except
  deleting logs, purging PPAs and removing repos.

  Order of execution is as follows.

  - Update repository metadata
  - Upgrade packages
  - Add Repositories
  - Add PPAs
  - Install Packages
  - Install DEB files
  - Install Static binaries
  - Install Snap Packages
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_debs="
  This will download and install debian packages mentioned in
  the config file. Please note that this is slightly less secure,
  as GPG signature verification is not done on the packages
  downloaded.
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_snaps="
  Install snap packages. If your system did not come preinstalled with
  snapd, it will be installed. If you are running a DNS server on the
  machine, lxd's dnsmasq might cause port conflicts.

  You must specify snaps under correct category.
  - classic (no confinement)
  - normal (default snap confinement)
  - edge (beta versions and some unconfined packages)

  ::WARNING::
  This task will fail inside docker containers!
  -------------------------------------------------------

  Proceed with this action?
  "

  __menu_info_bin="
  Install static binaries. This task will download and put
  your binaries in /usr/local/bin. Please ensure to use correct
  binaries for your system and ensure that
  /usr/local/bin is in your PATH.
  -------------------------------------------------------

  Proceed with this action?
  "

  whiptail_exitstatus=$?
  log_debug "Whiptail Exit status is : $whiptail_exitstatus"
  if [ $whiptail_exitstatus = 0 ]; then
    log_debug "Whiptail Task is: $task"
    case $task in
    update)
      _prompt_confirmation "$__menu_info_update" "update_repos_as_task"
      ;;
    upgrade)
      _prompt_confirmation "${__menu_info_upgrade}" "upgrade_apps"
      ;;
    ppas)
      _prompt_confirmation "${__menu_info_ppa}" "add_ppas"
      ;;
    repo)
      _prompt_confirmation "$__menu_info_add_repo" "add_repositories"
      ;;
    apps)
      _prompt_confirmation "$__menu_info_apps" "install_apps"
      ;;
    purge)
      _prompt_confirmation "${__menu_info_purge}" "purge_not_required"
      ;;
    all)
      _prompt_confirmation "${__menu_info_all}" "all_in_one"
      ;;
    debs)
      _prompt_confirmation "${__menu_info_debs}" "install_debs"
      ;;
    bin)
      _prompt_confirmation "${__menu_info_bin}" "install_binaries"
      ;;
    snaps)
      _prompt_confirmation "${__menu_info_snaps}" "install_snaps"
      ;;
    esac
  else
    log_debug "Whiptail Exit code : $whiptail_exitstatus"
    log_debug "Exiting because user selected Quit or Whiptail has non zero exit code."
  fi
}

function _ci_cloud_and_container_checks() {

  if [ "$bool_skip_env_checks" == "true" ]; then
    log_debug "Skipping Run environment checks"
  else
    log_stage "Running environment checks"
    # Check if running in CI & Containers
    # VMs, GCP, AWS, Docker.
    #================================ CI =============================================
    if [ "$TRAVIS" == "true" ]; then
      log_dev "Running on Travis CI"
    elif [ "$APPVEYOR" == "true" ]; then
      log_dev "Running on Appveyor CI"
    elif [ "$TF_BUILD" == "True" ]; then
      log_dev "Running on Azure Pipelines"
    elif [ "$GITHUB_ACTIONS" == "true" ]; then
      log_dev "Running on GitHub Actions"
    fi

    if grep -q Microsoft /proc/version; then
      log_warn "Running on Windows Subsystem for Linux"
    fi
    #============================ Docker =============================================
    if grep docker /proc/1/cgroup -qa; then
      log_dev "Running in docker"
    else
      log_debug "Probably not running in docker"
    fi
    #------------------------------- EC2, GCP, DO ------------------------------------
    # This first, simple check will work for many older instance types.
    if [ -f /sys/hypervisor/uuid ] && [ "$(head -c 3 /sys/hypervisor/uuid)" == "ec2" ]; then
      log_dev "Running on EC2"

    # This check will work on newer m5/c5 instances, but only if you have root!
    # If the file exists AND is readable by us, we can rely on it.
    elif [ -r /sys/devices/virtual/dmi/id/product_uuid ] && [ "$(head -c 3 /sys/devices/virtual/dmi/id/product_uuid)" == "EC2" ]; then
      log_dev "Running on EC2"

    # Fallback check of http://169.254.169.254/. If we wanted to be REALLY
    # authoritative, we could follow Amazon's suggestions for cryptographically
    # https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/instance-identity-documents.html
    # but this is almost certainly overkill for this purpose (and the above
    # checks of "EC2" prefixes have a higher false positive potential anyway).
    elif wget -O- -q --timeout=1 --tries=1 http://169.254.169.254/latest/dynamic/instance-identity/document | grep -q availabilityZone; then
      log_dev "Running on EC2"

    #------------------------------- GCP ---------------------------------------------
    elif wget -q -O- --timeout=1 --tries=1 -nc --header="Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/virtual-clock/drift-token >/dev/null; then
      log_dev "Running on Google Compute"

    elif wget -q -O- --timeout=1 --tries=1 -nc http://169.254.169.254/metadata/v1/id; then
      log_dev "Running on Digital Ocean droplet"

    elif AZURE_REGION="$(wget -q -O- --timeout=1 --tries=1 --header "Metadata:true" "${AZURE_METADATA_URL}")"; then
      log_dev "Running on Microsoft Azure ${AZURE_REGION}"

    else
      log_debug "Probably not running on AWS/GCP/Azure or Digital Ocean."
    fi

  fi

}

function display_version() {
  printf "%-15s : %s\n" "Version" "${AE_VERSION}"
  printf "%-15s : %s\n" "Executable" "${SCRIPT}"
}

function display_usage() {
  #Prints out help menu
  cat <<EOF

A Post Installation Script for Ubuntu, Debian,
Linux-Mint, elementaryOS, Pop!_OS, MX Linux etc.${NC}

Usage: ${TEAL} [sudo] ./${SCRIPT} ${ORANGE}  [options]${NC}
${YELLOW}
Non-Action options (can be run as non-root user)
---------------------------------------------------------${NC}
[-v | --version]      Display version info.
[-h | --help]         Display this help message.
${YELLOW}
Configuration Options
---------------------------------------------------------${NC}
[-c | --config-file]  Local yaml config file.
[-r | --remote-yaml]  Use config yaml from a URL.
${LIGHT_BLUE}
The following options are "action" options and will
make changes to your system depending on tasks selcted.
---------------------------------------------------------${NC}
[-d | --purge]        Enable Purging packages
[-f | --fix]          Fix codenames for new releases
[-p | --pre-release]  Same as --fix but for beta/alpha
                      releases of Ubuntu and Debian.
[--fix-mode-lts]      Similar to --fix but fallback to
                      last LTS. MUST be used with --fix.
                      Only works on Ubuntu and Debian.
[-k | --keep-debs]    Do not invoke apt-clean & do not
                      delete downloaded deb packages.
[-l | --delete-log]   Deletes the logfile.
                      (log/after-effects.log)
[-s | --simulate]     Try not to make changes to system
                      and use --dry-run Please read the
                      documentation, to know its limits
                      as everything cannot be simulated.
${YELLOW}
Other Options
---------------------------------------------------------${NC}
[--no-env-checks]     Skip some env checks.
[--no-version-check]  Skip checking for latest version
[-A | --autopilot]    Enables AUTOPILOT mode(No Prompts).
${GRAY}
Debugging Options
---------------------------------------------------------
[-nx | --nx]          Just process config but do not
                      make any changes to the system.
[--debug]             Prints debug logs.
[--debug-trace]       Prints trace level logs which
                      includes output from apt-get
                      and other commands.
${TEAL}
Documentation, License and Version Information
---------------------------------------------------------${NC}
Version : ${ORANGE}${AE_VERSION}${NC}
GitHub  : ${LIGHT_BLUE}https://git.io/ubuntu-post-install${NC}
Docs    : ${LIGHT_BLUE}https://ae.prasadt.com${NC}
License : ${ORANGE}GPLv3${NC}
---------------------------------------------------------${NC}
EOF
}

function _process_non_root_options() {
  # Process command line arguments which does not require root.
  if [[ $# -eq 0 ]]; then
    printf "${RED}✕ No arguments specified! See Usage Below${NC}\n"
    display_usage
    exit 1
  elif [[ $# -eq 1 ]]; then
    while [ "${1}" != "" ]; do
      case ${1} in
      -v | --version)
        display_version
        exit 0
        ;;
      -l | --delete-log)
        delete_log_file
        ;;
      -h | --help)
        display_usage
        exit 0
        ;;
      *)
        printf "${RED}✕ This does not appear to be a valid option${NC}\n"
        printf "${RED}✕ Non action options take more than one argument!${NC}\n"
        exit 1
        ;;
      esac
      shift
    done
  fi
}

function process_no_exec_option() {
  while [ "${1}" != "" ]; do
    case ${1} in
    -n | --nx) readonly AE_INTERNAL_NO_EXECUTE="true" ;;
    esac
    shift
  done
}

function main() {
  _init_printf_variables

  # Non root options
  _process_non_root_options "$@"

  printf "${MAGENTA}➜ Initialize & run checks${NC}\n"
  process_no_exec_option "$@"

  printf "  • Permission checks\n"

  if [[ $AE_INTERNAL_NO_EXECUTE == "true" ]]; then
    # Actual logging starts
    _init_logging
    log_dev "Running in NX mode"
  elif [[ $EUID -ne 0 ]]; then
    printf "${RED}✕ Insufficient privileges!!${NC}\n"
    printf "${RED}✕ This script must be run as root.\n"
    printf "${RED}✕ Please use sudo ${dir}/$SCRIPT to run this as root.\n"
    exit 2
  else
    # We were not running in NX mode, and we are root.
    _init_logging
    log_success "OK! Running as root"
  fi

  # Init vars
  _init_script_variables

  # Process command line arguments.
  while [ "${1}" != "" ]; do
    case ${1} in
    -s | --simulate)
      readonly simulate_apt_install="true"
      log_property "Simulate" "ENABLED" "3"
      ;;
    -f | --fix)
      bool_fix_repo_not_available_for_latest="true"
      log_property "Fix" "ENABLED" "2"
      ;;
    --fix-mode-lts)
      bool_fix_repo_lts="true"
      log_property "FIX MODE" "LTS" "2"
      ;;
    -p | --pre-release)
      bool_fix_repo_not_available_for_upcoming_release="true"
      log_property "FIX MODE" "PRE-RELEASE" "2"
      ;;
    -d | --purge)
      bool_purge_pkgs="true"
      log_notice "Purge packages is set to true."
      log_warn "No checks are being made on the packages in the list."
      log_warn "Use carefully!. Purging system packages is a stupid idea!"
      ;;
    -y | --yes)
      log_warn "-y | --yes is no longer available, Use Autopilot instead"
      ;;
    -k | --keep-debs)
      bool_preserve_debs="true"
      log_notice "Will keep downloaded DEB packages."
      ;;
    -V | --no-version-check)
      bool_check_version="false"
      ;;
    -r | --remote-yaml)
      log_property "Config file" "REMOTE" 4
      readonly bool_remote_yaml="true"
      shift
      readonly url_remote_yaml="${1}"
      ;;
    -c | --config-file | --config)
      shift
      readonly local_config_file="${1}"
      readonly bool_local_config="true"
      log_property "Config file" "LOCAL" 2
      ;;
    -H | --hide-config)
      log_warn "-H/--hide-config is no longer supported."
      log_and_exit "Use --debug or --debug-trace" "26"
      ;;
    -A | --autopilot)
      log_property "Autopilot" "ENABLED" "2"
      readonly AE_AUTOPILOT="true"
      ;;
    --use-uf-mirror)
      log_warn "Will use Uni-Freiburg mirror(s) if available"
      readonly bool_use_uf_mirror="true"
      ;;
    -E | --skip-env-checks) readonly bool_skip_env_checks="true" ;;
    # Debug options
    --debug) AE_DEBUG=1 ;;
    --debug-ci) AE_DEBUG=2 ;;
    --debug-trace) AE_DEBUG=3 ;;
    --debug-ci-mode)
      set -eo pipefail
      ;;
    -n | --nx) : ;;
    # The following arguments should always be used as the only arguments.
    -l | --delete-logfile) log_and_exit "-l or --delete-logfile should be the only argument." "23" ;;
    -v | --version) log_and_exit "-v or --version should be the only argument." "23" ;;
    -h | --help) log_and_exit "-h or --help should be the only argument." "23" ;;
    *) log_and_exit "Invalid option: $1" "22" ;;
    esac
    shift
  done

  # Check dependencies
  declare -ar after_effects_core_dependencies=(wget ping ps grep cut tr awk)

  log_info "Checking dependencies"

  if [[ ${AE_AUTOPILOT} != "true" ]]; then
    if command -v whiptail >/dev/null; then
      log_property "whiptail" "INSTALLED"
    else
      log_property "whiptail" "NOT INSTALLED" "4"
      log_error "--autopilot is not enabled, but whitptail binary is not found!"
      log_and_exit "Missing dependency - whiptail" "1"
    fi
  else
    log_debug "whiptail is not required as autopilot is active."
  fi

  _check_dependencies "${after_effects_core_dependencies[@]}"

  _init_print_basic_info

  # Did I tell you that I need to call My friends over internet?
  _test_internet_connection

  log_info "Checking configuration"

  # Handle Remote YAML
  log_var "bool_local_config"
  log_var "local_config_file"
  log_var "bool_remote_yaml"
  log_var "url_remote_yaml"

  if [[ -z ${local_config_file} ]] && [[ -z ${url_remote_yaml} ]]; then
    log_error "Undefined configuration!"
    log_and_exit "Did you forget to pass --config-file/--remote-yaml option?" "63"

  fi

  if [ "$bool_local_config" == "true" ] && [ "$bool_remote_yaml" == "true" ]; then
    log_and_exit "Cannot use local config (-c) with remote YAML (-r) Use one of them." "25"
  fi

  if [ "$bool_local_config" == "true" ] && [ ! -f "$local_config_file" ]; then
    log_and_exit "Config file you have specified is not found or not accessible" "36"
  fi

  log_success "OK"

  # Checks CI & Containers If running on EC2/GCP/Azure/DO
  _ci_cloud_and_container_checks

  # Take care of Mint and other distros
  _fix_ubuntu_derivatives

  # Get Remote Config File/s, check version & configure
  _version_checks

  _set_yaml_config

  log_stage "Check AUTOPILOT requirements"
  if [[ ! -t 1 ]] && [[ $AE_AUTOPILOT != "true" ]]; then
    log_error "Terminal is not interactive, yet you have not specified --autopilot flag!"
    log_and_exit "Non-interactive terminal requires --autopilot" "54"
  else
    log_success "OK"
  fi

  # I don't like when someone else is occupying my room
  # Test if any apt-get ops are running
  log_stage "Check for conflicting apps"
  _test_conflicting_apps

  if [[ $AE_INTERNAL_NO_EXECUTE == "true" ]]; then
    log_dev "Will not execute any tasks!"
    _script_exit_log
    exit 255
  fi

  # Autopilot
  log_stage "Checking for Autopilot"
  if [[ ${AE_AUTOPILOT} == "true" ]]; then
    log_success "Autopilot is ENABLED"
    sleep 3
    #log_and_exit "Because I can" "255"
    _autopilot_check_task_flag_and_run "$ae_task_update" "update_repos_as_task"
    _autopilot_check_task_flag_and_run "$ae_task_upgrade" "upgrade_apps"
    _autopilot_check_task_flag_and_run "$ae_task_repo" "add_repositories"
    _autopilot_check_task_flag_and_run "$ae_task_ppa" "add_ppas"
    _autopilot_check_task_flag_and_run "$ae_task_apt" "install_apps"
    _autopilot_check_task_flag_and_run "$ae_task_debs" "install_debs"
    _autopilot_check_task_flag_and_run "$ae_task_purge" "purge_not_required"
    _autopilot_check_task_flag_and_run "$ae_task_bin" "install_binaries"
    _autopilot_check_task_flag_and_run "$ae_task_snaps" "install_snaps"
  else
    sleep 2
    log_notice "Autopilot is Inactive"
    _process_menu
  fi

  _script_exit_log
}

#Run Main
main "$@"
